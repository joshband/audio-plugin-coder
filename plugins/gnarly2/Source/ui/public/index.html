<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nf_gnarly</title>
    <style>
        /* Swiss Minimal Aesthetic */

        :root {
            /* Colors */
            --bg-main: #FFFFFF;
            --text-primary: #000000;
            --text-secondary: #666666;
            --control-bg: #FFFFFF;
            --control-border: #000000;
            --graph-bg: #F8F8F8;
            --graph-line: #000000;
            --graph-fill: rgba(0, 0, 0, 0.1);

            /* Spacing */
            --spacing-comfortable: 20px;
            --spacing-section: 24px;

            /* Borders */
            --border-width: 2px;
            --border-color: #000000;
        }

        * {
            box-sizing: border-box;
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            background: var(--bg-main);
            color: var(--text-primary);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            user-select: none;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-section);
        }

        h1 {
            margin: 0 0 var(--spacing-section) 0;
            font-size: 24px;
            font-weight: 700;
            text-align: center;
            letter-spacing: 0.01em;
        }

        .plugin-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-comfortable);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--spacing-comfortable);
            padding: var(--spacing-section);
            border: var(--border-width) solid var(--border-color);
            width: 380px;
        }

        .control-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .rotary-knob {
            position: relative;
            width: 70px;
            height: 70px;
            border: var(--border-width) solid var(--border-color);
            border-radius: 50%;
            background: var(--control-bg);
            cursor: pointer;
        }

        .knob-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 25px;
            background: var(--border-color);
            transform-origin: center 25px;
        }

        .control-wrapper label {
            font-size: 14px;
            font-weight: 400;
            color: var(--text-primary);
            text-align: center;
        }

        .control-wrapper .value {
            font-size: 12px;
            font-weight: 400;
            color: var(--text-secondary);
            font-variant-numeric: tabular-nums;
        }

        .filter-graph {
            width: 380px;
            height: 120px;
            border: var(--border-width) solid var(--border-color);
            background: var(--graph-bg);
            position: relative;
        }

        .graph-canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <h1>nf_gnarly</h1>

    <div class="plugin-container">
        <!-- Filter Response Graph -->
        <div class="filter-graph">
            <canvas class="graph-canvas" id="filterGraph" width="380" height="120"></canvas>
        </div>

        <!-- Controls -->
        <div class="controls">
            <div class="control-wrapper">
                <div class="rotary-knob" data-param="drive">
                    <div class="knob-indicator" id="drive-indicator"></div>
                </div>
                <label>Drive</label>
                <div class="value" id="drive-value">0.0 dB</div>
            </div>

            <div class="control-wrapper">
                <div class="rotary-knob" data-param="cutoff">
                    <div class="knob-indicator" id="cutoff-indicator"></div>
                </div>
                <label>Cutoff</label>
                <div class="value" id="cutoff-value">1.0 kHz</div>
            </div>

            <div class="control-wrapper">
                <div class="rotary-knob" data-param="resonance">
                    <div class="knob-indicator" id="resonance-indicator"></div>
                </div>
                <label>Resonance</label>
                <div class="value" id="resonance-value">0.00</div>
            </div>
        </div>
    </div>

    <script>
        /******************************************************************************
         * PART 1: Native Interop (check_native_interop.js) - DO NOT MODIFY
         ******************************************************************************/
        if (typeof window.__JUCE__ !== "undefined" && typeof window.__JUCE__.getAndroidUserScripts !== "undefined" && typeof window.inAndroidUserScriptEval === "undefined") {
            window.inAndroidUserScriptEval = true;
            eval(window.__JUCE__.getAndroidUserScripts());
            delete window.inAndroidUserScriptEval;
        }
        if (typeof window.__JUCE__ === "undefined") {
            window.__JUCE__ = { postMessage: function () { } };
        }
        if (typeof window.__JUCE__.initialisationData === "undefined") {
            window.__JUCE__.initialisationData = { __juce__platform: [], __juce__functions: [], __juce__registeredGlobalEventIds: [], __juce__sliders: [], __juce__toggles: [], __juce__comboBoxes: [] };
        }

        class ListenerList {
            constructor() { this.listeners = new Map(); this.listenerId = 0; }
            addListener(fn) { const id = this.listenerId++; this.listeners.set(id, fn); return id; }
            removeListener(id) { this.listeners.delete(id); }
            callListeners(payload) { for (const [, value] of this.listeners) value(payload); }
        }
        class EventListenerList {
            constructor() { this.eventListeners = new Map(); }
            addEventListener(eventId, fn) { if (!this.eventListeners.has(eventId)) this.eventListeners.set(eventId, new ListenerList()); return [eventId, this.eventListeners.get(eventId).addListener(fn)]; }
            removeEventListener([eventId, id]) { if (this.eventListeners.has(eventId)) this.eventListeners.get(eventId).removeListener(id); }
            emitEvent(eventId, object) { if (this.eventListeners.has(eventId)) this.eventListeners.get(eventId).callListeners(object); }
        }
        class Backend {
            constructor() { this.listeners = new EventListenerList(); }
            addEventListener(eventId, fn) { return this.listeners.addEventListener(eventId, fn); }
            removeEventListener([eventId, id]) { this.listeners.removeEventListener(eventId, id); }
            emitEvent(eventId, object) { window.__JUCE__.postMessage(JSON.stringify({ eventId: eventId, payload: object })); }
            emitByBackend(eventId, object) { this.listeners.emitEvent(eventId, JSON.parse(object)); }
        }
        if (typeof window.__JUCE__.backend === "undefined") window.__JUCE__.backend = new Backend();

        /******************************************************************************
         * PART 2: JUCE Bridge (juce/index.js) - DO NOT MODIFY
         ******************************************************************************/
        class PromiseHandler {
            constructor() {
                this.lastPromiseId = 0;
                this.promises = new Map();
                window.__JUCE__.backend.addEventListener("__juce__complete", ({ promiseId, result }) => {
                    if (this.promises.has(promiseId)) { this.promises.get(promiseId).resolve(result); this.promises.delete(promiseId); }
                });
            }
            createPromise() { const id = this.lastPromiseId++; const r = new Promise((res, rej) => this.promises.set(id, { resolve: res, reject: rej })); return [id, r]; }
        }
        const promiseHandler = new PromiseHandler();

        class SliderState {
            constructor(name) {
                this.name = name;
                this.identifier = "__juce__slider" + this.name;
                this.scaledValue = 0;
                this.properties = { start: 0, end: 1, skew: 1, name: "", label: "", numSteps: 100, interval: 0, parameterIndex: -1 };
                this.valueChangedEvent = new ListenerList();
                this.propertiesChangedEvent = new ListenerList();
                window.__JUCE__.backend.addEventListener(this.identifier, (e) => {
                    if (e.eventType == "valueChanged") { this.scaledValue = e.value; this.valueChangedEvent.callListeners(); }
                    if (e.eventType == "propertiesChanged") { let { eventType: _, ...rest } = e; this.properties = rest; this.propertiesChangedEvent.callListeners(); }
                });
                window.__JUCE__.backend.emitEvent(this.identifier, { eventType: "requestInitialUpdate" });
            }
            setNormalisedValue(v) { this.scaledValue = this.snapToLegalValue(this.normalisedToScaledValue(v)); window.__JUCE__.backend.emitEvent(this.identifier, { eventType: "valueChanged", value: this.scaledValue }); }
            sliderDragStarted() { window.__JUCE__.backend.emitEvent(this.identifier, { eventType: "sliderDragStarted" }); }
            sliderDragEnded() { window.__JUCE__.backend.emitEvent(this.identifier, { eventType: "sliderDragEnded" }); }
            getNormalisedValue() { return Math.pow((this.scaledValue - this.properties.start) / (this.properties.end - this.properties.start), this.properties.skew); }
            getScaledValue() { return this.scaledValue; }
            normalisedToScaledValue(v) { return Math.pow(v, 1 / this.properties.skew) * (this.properties.end - this.properties.start) + this.properties.start; }
            snapToLegalValue(v) { const i = this.properties.interval; if (i == 0) return v; const s = this.properties.start; return Math.max(this.properties.start, Math.min(this.properties.end, s + i * Math.floor((v - s) / i + 0.5))); }
        }

        class ToggleState {
            constructor(name) {
                this.name = name;
                this.identifier = "__juce__toggle" + this.name;
                this.value = false;
                this.valueChangedEvent = new ListenerList();
                window.__JUCE__.backend.addEventListener(this.identifier, (e) => { if (e.eventType == "valueChanged") { this.value = e.value; this.valueChangedEvent.callListeners(); } });
                window.__JUCE__.backend.emitEvent(this.identifier, { eventType: "requestInitialUpdate" });
            }
            getValue() { return this.value; }
            setValue(v) { this.value = v; window.__JUCE__.backend.emitEvent(this.identifier, { eventType: "valueChanged", value: this.value }); }
        }

        const sliderStates = new Map();
        const getSliderState = (name) => { if (!sliderStates.has(name)) sliderStates.set(name, new SliderState(name)); return sliderStates.get(name); };
        const toggleStates = new Map();
        const getToggleState = (name) => { if (!toggleStates.has(name)) toggleStates.set(name, new ToggleState(name)); return toggleStates.get(name); };

        /******************************************************************************
         * PART 3: Plugin UI Logic (nf_gnarly specific)
         ******************************************************************************/
        const paramConfigs = {
            drive: { min: -24, max: 24, unit: ' dB', decimals: 1 },
            cutoff: { min: 20, max: 20000, unit: ' Hz', decimals: 0 },
            resonance: { min: 0, max: 1, unit: '', decimals: 2 }
        };

        function initializeKnobs() {
            document.querySelectorAll('.rotary-knob').forEach(knob => {
                const paramId = knob.dataset.param;
                const config = paramConfigs[paramId];
                const sliderState = getSliderState(paramId);
                const indicator = knob.querySelector('.knob-indicator');
                const valueDisplay = document.getElementById(paramId + '-value');
                let isDragging = false;
                let lastY = 0;

                function updateKnobVisual() {
                    const norm = sliderState.getNormalisedValue();
                    const rotation = -135 + (norm * 270);
                    indicator.style.transform = `translateX(-50%) rotate(${rotation}deg)`;

                    if (valueDisplay) {
                        const scaled = sliderState.getScaledValue();
                        let displayValue;

                        if (paramId === 'cutoff') {
                            displayValue = scaled >= 1000 ?
                                `${(scaled / 1000).toFixed(1)} kHz` :
                                `${Math.round(scaled)} Hz`;
                        } else if (paramId === 'drive') {
                            displayValue = `${scaled.toFixed(config.decimals)}${config.unit}`;
                        } else {
                            displayValue = scaled.toFixed(config.decimals);
                        }

                        valueDisplay.textContent = displayValue;
                    }
                }

                sliderState.valueChangedEvent.addListener(updateKnobVisual);
                updateKnobVisual();

                knob.addEventListener('mousedown', e => {
                    isDragging = true;
                    lastY = e.clientY;
                    sliderState.sliderDragStarted();
                    e.preventDefault();
                });

                document.addEventListener('mousemove', e => {
                    if (!isDragging) return;
                    const deltaY = lastY - e.clientY;
                    lastY = e.clientY;
                    const newNorm = Math.max(0, Math.min(1, sliderState.getNormalisedValue() + deltaY * 0.005));
                    sliderState.setNormalisedValue(newNorm);
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        sliderState.sliderDragEnded();
                    }
                });

                knob.addEventListener('wheel', e => {
                    e.preventDefault();
                    const newNorm = Math.max(0, Math.min(1, sliderState.getNormalisedValue() + (e.deltaY > 0 ? -0.02 : 0.02)));
                    sliderState.setNormalisedValue(newNorm);
                });
            });
        }

        function initializeFilterGraph() {
            const canvas = document.getElementById('filterGraph');
            const ctx = canvas.getContext('2d');

            function updateGraph() {
                const driveState = getSliderState('drive');
                const cutoffState = getSliderState('cutoff');
                const resonanceState = getSliderState('resonance');

                const drive = driveState.getScaledValue();
                const cutoff = cutoffState.getScaledValue();
                const resonance = resonanceState.getScaledValue();

                const width = canvas.width;
                const height = canvas.height;

                // Clear and draw background
                ctx.fillStyle = '#F8F8F8';
                ctx.fillRect(0, 0, width, height);

                // Draw grid
                ctx.strokeStyle = '#E0E0E0';
                ctx.lineWidth = 1;

                for (let i = 0; i <= 10; i++) {
                    const x = (i / 10) * width;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }

                for (let i = 0; i <= 4; i++) {
                    const y = (i / 4) * height;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }

                // Draw filter response curve
                drawFilterResponse(ctx, width, height, cutoff, resonance, drive);
            }

            function drawFilterResponse(ctx, width, height, cutoff, resonance, drive) {
                const q = 0.7 + resonance * 49.3;
                const driveGain = Math.pow(10, drive / 20);

                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.beginPath();

                const points = [];
                for (let i = 0; i <= 300; i++) {
                    const freq = 20 * Math.pow(20000 / 20, i / 300);
                    const response = calculateFilterResponse(freq, cutoff, q, driveGain);
                    points.push({ freq, response });
                }

                points.forEach((point, index) => {
                    const x = (Math.log(point.freq / 20) / Math.log(20000 / 20)) * width;
                    const responseDB = 20 * Math.log10(Math.max(0.0001, Math.abs(point.response)));
                    const y = (1 - (responseDB + 24) / 48) * height;

                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();

                // Fill under curve
                ctx.lineTo(width, height);
                ctx.lineTo(0, height);
                ctx.closePath();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fill();
            }

            function calculateFilterResponse(freq, cutoff, q, driveGain) {
                const w0 = 2 * Math.PI * cutoff;
                const w = 2 * Math.PI * freq;
                const k = w / w0;

                const denominator = k*k*k*k + k*k/(q*q) - k*k*(2 - 1/(q*q)) + 1;
                const lpMagnitude = 1 / Math.sqrt(Math.max(0.0001, denominator));
                const finalMagnitude = lpMagnitude * driveGain;

                return finalMagnitude;
            }

            // Update graph when parameters change
            getSliderState('drive').valueChangedEvent.addListener(updateGraph);
            getSliderState('cutoff').valueChangedEvent.addListener(updateGraph);
            getSliderState('resonance').valueChangedEvent.addListener(updateGraph);

            // Initial draw
            updateGraph();
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.addEventListener('contextmenu', e => e.preventDefault());
            document.addEventListener('dragstart', e => e.preventDefault());
            initializeKnobs();
            initializeFilterGraph();
        });
    </script>
</body>
</html>
