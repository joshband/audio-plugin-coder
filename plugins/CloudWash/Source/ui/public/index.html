<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CloudWash - Granular Texture Processor</title>
    <style>
        :root {
            --bg-primary: #1A1A2E;
            --bg-surface: #2A2A3E;
            --bg-raised: #3A3A4E;
            --brand-teal: #427E88;
            --brand-cyan: #5AC8D8;
            --text-primary: #FFFFFF;
            --text-secondary: #A0A0B0;
            --text-muted: #707085;
            --color-active: #427E88;
            --color-success: #4CAF50;
            --color-warning: #FFC107;
            --color-danger: #FF4444;
            --viz-top: #3A4A6E;
            --viz-bottom: #1A1A2E;
            --glow-teal: rgba(66, 126, 136, 0.4);
            --font-primary: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-primary);
            background: var(--bg-primary);
            color: var(--text-primary);
            width: 800px;
            height: 500px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            user-select: none;
        }


        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px;
            background: var(--bg-primary);
        }

        .plugin-title {
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 2px;
            color: var(--text-primary);
        }

        .mode-tabs {
            display: flex;
            gap: 2px;
            background: var(--bg-surface);
            border-radius: 6px;
            padding: 2px;
        }

        .mode-tab {
            width: 100px;
            height: 32px;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 200ms ease-in-out;
        }

        .mode-tab:hover {
            background: var(--bg-raised);
        }

        .mode-tab.active {
            background: var(--brand-teal);
            box-shadow: 0 2px 8px var(--glow-teal);
        }

        .grain-visualization {
            width: calc(100% - 60px);
            height: 60px;
            margin: 0 30px 15px 30px;
            background: linear-gradient(to bottom, var(--viz-top), var(--viz-bottom));
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        #grainCanvas {
            width: 100%;
            height: 100%;
        }

        .logo-container {
            width: 36px;
            height: 36px;
            opacity: 1;
            pointer-events: auto;
            transition: opacity 200ms ease;
            margin-bottom: 10px;
            display: block;
            cursor: pointer;
        }

        .logo-container:hover {
            opacity: 1;
        }

        .logo-container svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls-wrapper {
            flex: 1;
            display: flex;
            padding: 0 30px;
            gap: 15px;
        }

        .left-meter-container,
        .right-meter-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .controls-center {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px 18px;
        }

        .knob-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .knob-label {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        .knob {
            width: 70px;
            height: 70px;
            cursor: ns-resize;
            position: relative;
        }

        .knob:hover .knob-arc {
            filter: drop-shadow(0 0 8px var(--glow-teal));
        }

        .knob.active .knob-arc {
            filter: drop-shadow(0 0 12px var(--glow-teal));
        }

        .knob-track {
            fill: none;
            stroke: var(--bg-surface);
            stroke-width: 6;
            stroke-linecap: round;
        }

        .knob-arc {
            fill: none;
            stroke: var(--brand-teal);
            stroke-width: 6;
            stroke-linecap: round;
            /* NO transition - causes glitchy/jumpy rendering during drag */
        }

        .knob-arc.pitch {
            stroke: var(--brand-cyan);
        }

        .knob-marker {
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 6px;
            background: var(--text-muted);
            border-radius: 1px;
            opacity: 0.6;
        }

        .knob-indicator {
            width: 7px;
            height: 7px;
            background: var(--text-primary);
            border-radius: 50%;
            position: absolute;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }

        .knob-value {
            font-size: 12px;
            font-weight: 400;
            color: var(--text-secondary);
            font-variant-numeric: tabular-nums;
        }

        .meter-label {
            font-size: 9px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .meter {
            width: 32px;
            height: 240px;
            background: var(--bg-surface);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column-reverse;
        }

        .meter-segment {
            width: 100%;
            height: 4.17%;
            background: var(--bg-raised);
            margin-top: 1px;
            transition: background 20ms ease;
        }

        .meter-segment.active.green {
            background: var(--color-success);
            box-shadow: 0 0 3px var(--color-success);
        }

        .meter-segment.active.yellow {
            background: var(--color-warning);
            box-shadow: 0 0 3px var(--color-warning);
        }

        .meter-segment.active.red {
            background: var(--color-danger);
            box-shadow: 0 0 4px var(--color-danger);
        }

        .footer {
            padding: 0 30px 12px 30px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            position: relative;
        }

        .footer-container {
            background: var(--bg-surface);
            border: 1px solid var(--bg-raised);
            border-radius: 8px;
            padding: 10px 14px;
            display: flex;
            align-items: center;
            gap: 14px;
            margin: 0 auto;
        }

        .dropdown {
            width: 120px;
            height: 30px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-raised);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 10px;
            padding: 0 10px;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23A0A0B0' d='M2 4l4 4 4-4z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
        }

        .dropdown:hover {
            background: var(--bg-surface);
            border-color: var(--brand-teal);
        }

        .freeze-button {
            width: 140px;
            height: 36px;
            background: var(--bg-raised);
            border: 2px solid var(--bg-surface);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 150ms ease;
        }

        .freeze-button:hover {
            background: var(--bg-surface);
            border-color: var(--brand-teal);
        }

        .freeze-button.active {
            background: var(--brand-teal);
            border-color: var(--brand-cyan);
            box-shadow: 0 4px 12px var(--glow-teal);
        }

        .freeze-led {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--bg-surface);
            border: 2px solid var(--bg-raised);
            transition: all 150ms ease;
        }

        .freeze-led.active {
            background: var(--color-danger);
            border-color: var(--color-danger);
            box-shadow: 0 0 8px var(--color-danger), 0 0 16px rgba(255, 68, 68, 0.4);
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.6;
            }

            50% {
                opacity: 1.0;
            }
        }

        /* DEBUG OVERLAY */
        .debug-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            font-family: monospace;
            font-size: 11px;
            z-index: 10000;
            display: none;
            border-bottom: 2px solid #ff4444;
        }

        .debug-overlay.active {
            display: block;
        }

        .debug-overlay.connected {
            border-bottom-color: #44ff44;
        }

        .debug-status {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .debug-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4444;
        }

        .debug-indicator.connected {
            background: #44ff44;
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="plugin-title">CLOUDWASH</div>
        <div class="mode-tabs">
            <button class="mode-tab active" data-mode="0">GRANULAR</button>
            <button class="mode-tab" data-mode="1">PITCH</button>
            <button class="mode-tab" data-mode="2">DELAY</button>
            <button class="mode-tab" data-mode="3">SPECTRAL</button>
        </div>
    </div>

    <div class="grain-visualization">
        <canvas id="grainCanvas"></canvas>
    </div>

    <div class="controls-wrapper">
        <div class="left-meter-container">
            <div class="meter-label">IN</div>
            <div class="meter" id="inputMeter"></div>
        </div>

        <div class="controls-center">
            <div class="controls-grid">
                <!-- ROW 1 -->
                <div class="knob-container">
                    <div class="knob-label">POSITION</div>
                    <div class="knob" data-param="position" data-min="0" data-max="1" data-default="0.5">
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">50%</div>
                </div>

                <div class="knob-container">
                    <div class="knob-label">TEXTURE</div>
                    <div class="knob" data-param="texture" data-min="0" data-max="1" data-default="0.5">
                        <div class="knob-marker"></div>
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">50%</div>
                </div>

                <div class="knob-container">
                    <div class="knob-label">PITCH</div>
                    <div class="knob" data-param="pitch" data-min="-2" data-max="2" data-default="0">
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc pitch" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">+0.00</div>
                </div>

                <div class="knob-container">
                    <div class="knob-label">DENSITY</div>
                    <div class="knob" data-param="density" data-min="0" data-max="1" data-default="0.5" id="densityKnob">
                        <div class="knob-marker"></div>
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value" id="densityValue">0%</div>
                </div>

                <div class="knob-container">
                    <div class="knob-label">FEEDBACK</div>
                    <div class="knob" data-param="feedback" data-min="0" data-max="1" data-default="0">
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">0%</div>
                </div>

                <!-- ROW 2 -->
                <div class="knob-container">
                    <div class="knob-label">SIZE</div>
                    <div class="knob" data-param="size" data-min="0" data-max="1" data-default="0.5">
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">50%</div>
                </div>

                <div class="knob-container">
                    <div class="knob-label">IN GAIN</div>
                    <div class="knob" data-param="in_gain" data-min="0" data-max="1" data-default="0.8">
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">80%</div>
                </div>

                <div class="knob-container">
                    <div class="knob-label">BLEND</div>
                    <div class="knob" data-param="blend" data-min="0" data-max="1" data-default="0.5">
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">50%</div>
                </div>

                <div class="knob-container">
                    <div class="knob-label">SPREAD</div>
                    <div class="knob" data-param="spread" data-min="0" data-max="1" data-default="0">
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">0%</div>
                </div>

                <div class="knob-container">
                    <div class="knob-label">REVERB</div>
                    <div class="knob" data-param="reverb" data-min="0" data-max="1" data-default="0">
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">0%</div>
                </div>
            </div>
        </div>

        <div class="right-meter-container">
            <div class="meter-label">OUT</div>
            <div class="meter" id="outputMeter"></div>
        </div>
    </div>

    <div class="footer">
        <div class="footer-container">
            <select class="dropdown" id="presetSelect" style="width: 200px;">
                <option value="" disabled selected>Select Preset</option>
                <option value="init">01 - Init</option>
                <option value="cloud">02 - Ethereal Cloud</option>
                <option value="storm">03 - Grain Storm</option>
                <option value="spectral">04 - Spectral Wash</option>
                <option value="lofi">05 - Lo-Fi Dream</option>
                <option value="frozen">06 - Frozen Moment</option>
                <option value="reverse">07 - Reverse Echo</option>
                <option value="shimmer">08 - Shimmer Verb</option>
                <option value="glitch">09 - Glitch Machine</option>
                <option value="pitchshift">10 - Pitch Shifter</option>
                <option value="loop">11 - Looping Delay</option>
                <option value="ambient">12 - Ambient Pad</option>
                <option value="octup">13 - Octave Up</option>
                <option value="octdown">14 - Octave Down</option>
                <option value="specfreeze">15 - Spectral Freeze</option>
                <option value="dense">16 - Dense Texture</option>
                <option value="sparse">17 - Sparse Grains</option>
                <option value="cascade">18 - Pitch Cascade</option>
                <option value="resonant">19 - Resonant Delay</option>
                <option value="chaos">20 - Granular Chaos</option>
            </select>
            <select class="dropdown" id="qualitySelect" data-param="quality">
                <option value="0">Hi-Fi Stereo (1s)</option>
                <option value="1">Hi-Fi Mono (2s)</option>
                <option value="2">Lo-Fi Stereo (4s)</option>
                <option value="3">Lo-Fi Mono (8s)</option>
                <option value="4" selected>Ultra HQ (Long)</option>
            </select>
            <button class="freeze-button" id="freezeButton" data-param="freeze">FREEZE</button>
            <div class="freeze-led" id="freezeLED"></div>
        </div>

        <div class="logo-container" id="logoLink">
            <svg viewBox="0 0 89.98 89.84" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                <defs>
                    <style>
                        .st0 { fill: #fff200; fill-rule: evenodd; }
                        .st1 { fill: #b1b3b6; fill-rule: evenodd; }
                        .st2 { fill: #808285; fill-rule: evenodd; }
                        .st3 { fill: #464547; fill-rule: evenodd; }
                    </style>
                    <symbol id="Logo_2" viewBox="0 0 900 900">
                        <path class="st3" d="M471.6.45c115,4.84,213.87,48.62,296.6,131.35,85.12,85.12,129.03,187.32,131.72,306.6.05,3.86.08,7.72.08,11.6v.45c0,5.18-.04,10.35-.12,15.5-3.7,117.41-47.59,218.16-131.67,302.25-87.76,87.76-193.68,131.69-317.75,131.8h-.45c-124.27,0-230.33-43.93-318.2-131.8C44.04,680.44.11,574.52,0,450.45v-.45c0-124.27,43.93-230.33,131.8-318.2C214.53,49.07,313.4,5.29,428.4.45c7.14-.3,14.34-.45,21.6-.45h.45c7.11,0,14.16.16,21.15.45Z"/>
                    </symbol>
                    <symbol id="Logo_3" viewBox="0 0 801.9 899.55">
                        <path class="st1" d="M396,361.05v1.05l69.9,69.9h-96.9v-37.12c.27-9.45,3.78-17.56,10.55-24.33,4.81-4.81,10.29-7.97,16.45-9.5ZM740.35,677.35l-209.35-209.35v-36l222.23,222.23c-4.03,7.82-8.32,15.53-12.87,23.12ZM369,468l299.98,299.98c-6.06,6.06-12.21,11.91-18.45,17.55-12.88,11.64-26.13,22.39-39.75,32.25l-262.87-262.87c14.07-14.07,21.1-31.03,21.1-50.9v-36ZM351,899.55c-9.51,0-18.92-.26-28.23-.77L0,576v-180.92c.22-9.54,3.74-17.71,10.55-24.53,5.03-5.03,10.79-8.26,17.3-9.7l502.83,502.82c-12.81,5.57-25.88,10.5-39.22,14.78-25.6,8.2-52.18,14.01-79.75,17.42l-18.83,1.95c-13.58,1.14-27.38,1.71-41.42,1.72h-.45Z"/>
                        <path class="st1" d="M796.52,382.52c1.81,13.05,3.08,26.31,3.8,39.8l-62.33-62.33v-36l58.52,58.52Z"/>
                    </symbol>
                    <symbol id="Logo_4" viewBox="0 0 837.9 898.77">
                        <path class="st2" d="M432,362.1v-1.05c2.85-.7,5.85-1.05,9-1.05h333l62.92,62.92v15.03c.05,3.86.08,7.72.08,11.6v.45c0,5.18-.04,10.35-.12,15.5-2.16,68.6-18.04,131.51-47.65,188.73l-222.23-222.23h-65.1l-69.9-69.9ZM704.98,767.98l-299.98-299.98h162l209.35,209.35c-19.18,32.01-42.9,62.15-71.15,90.4-.08.08-.15.15-.23.23ZM602.8,845.8c-11.79,6.56-23.83,12.52-36.12,17.87L63.85,360.85c2.6-.57,5.32-.85,8.15-.85,7.49,0,14.16,2,20,6,1.91,1.31,3.72,2.82,5.45,4.55,1.73,1.73,4.23,4.21,7.5,7.45l166.25,166.05c4.96,4.93,8.6,8.55,10.9,10.85s4.69,4.42,7.15,6.35c12.55,9.83,27.14,14.75,43.75,14.75,19.87,0,36.83-7.03,50.9-21.1l262.87,262.87c-14.25,10.32-28.91,19.66-43.98,28.02ZM36,576l322.77,322.77c-13.52-.75-26.81-2.04-39.88-3.87L0,576h36Z"/>
                    </symbol>
                    <symbol id="Logo_5" viewBox="0 0 774 252">
                        <path class="st0" d="M441,0h333v36h-333c-9.93,0-18.42,3.52-25.45,10.55-7.03,7.03-10.55,15.52-10.55,25.45v36h162v36h-162v36c0,19.87-7.03,36.83-21.1,50.9-14.07,14.07-31.03,21.1-50.9,21.1-16.61,0-31.2-4.92-43.75-14.75-2.46-1.93-4.85-4.05-7.15-6.35s-5.94-5.92-10.9-10.85L104.95,54c-3.27-3.24-5.77-5.72-7.5-7.45-1.73-1.73-3.54-3.24-5.45-4.55-5.84-4-12.51-6-20-6-9.93,0-18.42,3.52-25.45,10.55-7.03,7.03-10.55,15.52-10.55,25.45v180H0V72c0-19.87,7.03-36.83,21.1-50.9C35.17,7.03,52.13,0,72,0c16.61,0,31.2,4.92,43.75,14.75,2.46,1.93,4.85,4.05,7.15,6.35s5.44,5.42,9.4,9.35l164.7,164.45c5.31,5.31,8.82,8.82,10.55,10.55,1.73,1.73,3.54,3.24,5.45,4.55,5.84,4,12.51,6,20,6,9.93,0,18.42-3.52,25.45-10.55,7.03-7.03,10.55-15.52,10.55-25.45v-108c0-19.87,7.03-36.83,21.1-50.9,14.07-14.07,31.03-21.1,50.9-21.1Z"/>
                    </symbol>
                </defs>
                <use width="900" height="900" transform="translate(0 -.04) scale(.1)" xlink:href="#Logo_2"/>
                <use width="801.9" height="899.55" transform="translate(9.89) scale(.1)" xlink:href="#Logo_3"/>
                <use width="837.9" height="898.77" transform="translate(6.29) scale(.1)" xlink:href="#Logo_4"/>
                <use width="774" height="252" transform="translate(6.29 32.36) scale(.1)" xlink:href="#Logo_5"/>
            </svg>
        </div>
    </div>

    <!-- Inline JavaScript - No CORS issues -->
    <!--
        JUCE LIBRARY IMPLEMENTATION NOTE:
        This inline JUCE library implementation is the ACTIVE version used by the plugin.
        There is a duplicate ES6 module version in js/index.js which is NOT used.
        
        The inline version is more complete and has better error handling.
        When making changes to JUCE bindings, update this inline version.
        
        The js/index.js file is kept for reference but is not loaded by the plugin.
        See PluginEditor.cpp which loads resources via the resource provider.
    -->
    <script>
        // ============================================================================
        // JUCE LIBRARY (INLINED) - Simplified for CloudWash
        // ============================================================================
        (function () {
            'use strict';

            try {
                // Check if JUCE backend is available (with retry for WebView2 initialization)
                let isJuceAvailable = typeof window.__JUCE__ !== 'undefined';

                if (!isJuceAvailable) {
                    console.warn("JUCE backend not immediately available - will retry after page load");
                    // Don't return immediately - we'll check again in DOMContentLoaded
                } else {
                    console.log("JUCE backend detected immediately - initializing parameter bindings");
                }

                // Global JUCE API object
                window.Juce = window.Juce || {};

            // Slider State Management
            class SliderState {
                constructor(name) {
                    this.name = name;
                    this.identifier = "__juce__slider" + name;
                    this.scaledValue = 0;
                    this.properties = {
                        start: 0,
                        end: 1,
                        skew: 1,
                        name: "",
                        label: "",
                        numSteps: 100,
                        interval: 0,
                        parameterIndex: -1,
                    };
                    this.valueChangedListeners = [];

                    if (window.__JUCE__ && window.__JUCE__.backend) {
                        window.__JUCE__.backend.addEventListener(this.identifier, (event) => this.handleEvent(event));
                        window.__JUCE__.backend.emitEvent(this.identifier, { eventType: "requestInitialUpdate" });
                    }
                }

                setNormalisedValue(newValue) {
                    this.scaledValue = this.snapToLegalValue(this.normalisedToScaledValue(newValue));
                    if (window.__JUCE__ && window.__JUCE__.backend) {
                        window.__JUCE__.backend.emitEvent(this.identifier, {
                            eventType: "valueChanged",
                            value: this.scaledValue
                        });
                    }
                }

                sliderDragStarted() {
                    if (window.__JUCE__ && window.__JUCE__.backend) {
                        window.__JUCE__.backend.emitEvent(this.identifier, {
                            eventType: "sliderDragStarted"
                        });
                    }
                }

                sliderDragEnded() {
                    if (window.__JUCE__ && window.__JUCE__.backend) {
                        window.__JUCE__.backend.emitEvent(this.identifier, {
                            eventType: "sliderDragEnded"
                        });
                    }
                }

                handleEvent(event) {
                    if (event.eventType === "valueChanged") {
                        this.scaledValue = event.value;
                        this.valueChangedListeners.forEach(fn => fn());
                    }
                    if (event.eventType === "propertiesChanged") {
                        const { eventType, ...rest } = event;
                        this.properties = rest;
                    }
                }

                getScaledValue() {
                    return this.scaledValue;
                }

                getNormalisedValue() {
                    return Math.pow(
                        (this.scaledValue - this.properties.start) / (this.properties.end - this.properties.start),
                        this.properties.skew
                    );
                }

                normalisedToScaledValue(normalisedValue) {
                    return Math.pow(normalisedValue, 1 / this.properties.skew) *
                        (this.properties.end - this.properties.start) + this.properties.start;
                }

                snapToLegalValue(value) {
                    const interval = this.properties.interval;
                    if (interval === 0) return value;

                    const start = this.properties.start;
                    const clamp = (val, min = 0, max = 1) => Math.max(min, Math.min(max, val));
                    return clamp(
                        start + interval * Math.floor((value - start) / interval + 0.5),
                        this.properties.start,
                        this.properties.end
                    );
                }

                addValueChangedListener(fn) {
                    this.valueChangedListeners.push(fn);
                }
            }

            // Toggle State Management
            class ToggleState {
                constructor(name) {
                    this.name = name;
                    this.identifier = "__juce__toggle" + name;
                    this.value = false;
                    this.valueChangedListeners = [];

                    if (window.__JUCE__ && window.__JUCE__.backend) {
                        window.__JUCE__.backend.addEventListener(this.identifier, (event) => this.handleEvent(event));
                        window.__JUCE__.backend.emitEvent(this.identifier, { eventType: "requestInitialUpdate" });
                    }
                }

                getValue() {
                    return this.value;
                }

                setValue(newValue) {
                    this.value = newValue;
                    if (window.__JUCE__ && window.__JUCE__.backend) {
                        window.__JUCE__.backend.emitEvent(this.identifier, {
                            eventType: "valueChanged",
                            value: this.value
                        });
                    }
                }

                handleEvent(event) {
                    if (event.eventType === "valueChanged") {
                        this.value = event.value;
                        this.valueChangedListeners.forEach(fn => fn());
                    }
                }

                addValueChangedListener(fn) {
                    this.valueChangedListeners.push(fn);
                }
            }

            // ComboBox State Management
            class ComboBoxState {
                constructor(name) {
                    this.name = name;
                    this.identifier = "__juce__comboBox" + name;
                    this.value = 0.0;
                    this.properties = {
                        name: "",
                        parameterIndex: -1,
                        choices: []
                    };
                    this.valueChangedListeners = [];

                    if (window.__JUCE__ && window.__JUCE__.backend) {
                        window.__JUCE__.backend.addEventListener(this.identifier, (event) => this.handleEvent(event));
                        window.__JUCE__.backend.emitEvent(this.identifier, { eventType: "requestInitialUpdate" });
                    }
                }

                getChoiceIndex() {
                    return Math.round(this.value * (this.properties.choices.length - 1));
                }

                setChoiceIndex(index) {
                    const numItems = this.properties.choices.length;
                    this.value = numItems > 1 ? index / (numItems - 1) : 0.0;

                    if (window.__JUCE__ && window.__JUCE__.backend) {
                        window.__JUCE__.backend.emitEvent(this.identifier, {
                            eventType: "valueChanged",
                            value: this.value
                        });
                    }
                }

                handleEvent(event) {
                    if (event.eventType === "valueChanged") {
                        this.value = event.value;
                        this.valueChangedListeners.forEach(fn => fn());
                    }
                    if (event.eventType === "propertiesChanged") {
                        const { eventType, ...rest } = event;
                        this.properties = rest;
                    }
                }

                addValueChangedListener(fn) {
                    this.valueChangedListeners.push(fn);
                }
            }

            // Caches
            const sliderStates = new Map();
            const toggleStates = new Map();
            const comboBoxStates = new Map();

            // Public API
            window.Juce = window.Juce || {};

            window.Juce.getSliderState = function (name) {
                if (!sliderStates.has(name)) {
                    const state = new SliderState(name);
                    sliderStates.set(name, state);
                    console.log(`Created SliderState for: ${name}`, state);
                }
                return sliderStates.get(name);
            };

            window.Juce.getToggleState = function (name) {
                if (!toggleStates.has(name)) {
                    const state = new ToggleState(name);
                    toggleStates.set(name, state);
                    console.log(`Created ToggleState for: ${name}`, state);
                }
                return toggleStates.get(name);
            };

            window.Juce.getComboBoxState = function (name) {
                if (!comboBoxStates.has(name)) {
                    const state = new ComboBoxState(name);
                    comboBoxStates.set(name, state);
                    console.log(`Created ComboBoxState for: ${name}`, state);
                }
                return comboBoxStates.get(name);
            };

                console.log("JUCE parameter binding functions initialized");

            } catch (error) {
                console.error("CRITICAL ERROR in JUCE library initialization:", error);
                console.error("Error stack:", error.stack);
                window.juceLibraryError = error; // Store for debugging
            }
        })();

        // ============================================================================
        // CLOUDWASH UI IMPLEMENTATION
        // ============================================================================
        console.log("CloudWash Starting initialization...");

        // ============================================================================
        // LOGO LINK HANDLER - Opens noizefield.com in External Browser
        // ============================================================================
        function initializeLogoLink() {
            const logoElement = document.getElementById('logoLink');

            if (!logoElement) {
                console.warn('Logo element not found');
                return;
            }

            // Make logo clickable
            logoElement.style.cursor = 'pointer';

            logoElement.addEventListener('click', () => {
                console.log('Logo clicked - opening noizefield.com');

                // Send event to JUCE backend to open URL in default browser
                if (window.__JUCE__ && window.__JUCE__.backend) {
                    window.__JUCE__.backend.emitEvent("openExternalURL", {
                        url: "https://noizefield.com"
                    });
                } else {
                    console.warn('JUCE backend not available - cannot open external URL');
                }
            });

            console.log('✓ Logo is clickable (opens https://noizefield.com in external browser)');
        }

        document.addEventListener("DOMContentLoaded", () => {
            console.log("=== CloudWash Initialization ===");

            // Re-check JUCE availability after DOM load (WebView2 may need time to initialize)
            setTimeout(() => {
                let errorDetails = "";

                try {
                    const juceNowAvailable = typeof window.__JUCE__ !== 'undefined';
                    const hasBackend = juceNowAvailable && window.__JUCE__.backend;

                    if (hasBackend) {
                            console.log("✓ JUCE backend is CONNECTED");
                        } else {
                            console.warn("⚠ JUCE backend NOT CONNECTED");
    
                            // Detailed diagnostics
                            if (!juceNowAvailable) {
                                errorDetails = "window.__JUCE__ does not exist - Native integration not enabled";
                                console.error("CRITICAL: window.__JUCE__ is undefined");
                                console.error("This means .withNativeIntegrationEnabled() is not working");
                            } else if (!window.__JUCE__.backend) {
                                errorDetails = "window.__JUCE__ exists but .backend is missing";
                                console.error("CRITICAL: window.__JUCE__.backend is undefined");
                                console.error("window.__JUCE__ contents:", window.__JUCE__);
                            }
                        }
    
                        // Try to initialize UI anyway (knobs will work visually but not control audio)
                    // Wrap each init function to find which one fails
                    try {
                        console.log("Initializing knobs...");
                        initializeKnobs();
                        console.log("✓ Knobs initialized");
                    } catch (e) {
                        console.error("✗ Knobs init failed:", e);
                        throw new Error("Knobs: " + e.message);
                    }

                    try {
                        console.log("Initializing mode tabs...");
                        initializeModeTabs();
                        console.log("✓ Mode tabs initialized");
                    } catch (e) {
                        console.error("✗ Mode tabs init failed:", e);
                        throw new Error("ModeTabs: " + e.message);
                    }

                    try {
                        console.log("Initializing freeze button...");
                        initializeFreezeButton();
                        console.log("✓ Freeze button initialized");
                    } catch (e) {
                        console.error("✗ Freeze button init failed:", e);
                        throw new Error("Freeze: " + e.message);
                    }

                    try {
                        console.log("Initializing dropdowns...");
                        initializeDropdowns();
                        console.log("✓ Dropdowns initialized");
                    } catch (e) {
                        console.error("✗ Dropdowns init failed:", e);
                        throw new Error("Dropdowns: " + e.message);
                    }

                    try {
                        console.log("Initializing meters...");
                        initializeMeters();
                        console.log("✓ Meters initialized");
                    } catch (e) {
                        console.error("✗ Meters init failed:", e);
                        throw new Error("Meters: " + e.message);
                    }

                    try {
                        console.log("Initializing grain visualization...");
                        initializeGrainVisualization();
                        console.log("✓ Grain visualization initialized");
                    } catch (e) {
                        console.error("✗ Grain viz init failed:", e);
                        throw new Error("GrainViz: " + e.message);
                    }

                    try {
                        console.log("Initializing presets...");
                        initializePresets();
                        console.log("✓ Presets initialized");
                    } catch (e) {
                        console.error("✗ Presets init failed:", e);
                        throw new Error("Presets: " + e.message);
                    }

                    try {
                        console.log("Initializing logo link...");
                        initializeLogoLink();
                        console.log("✓ Logo link initialized");
                    } catch (e) {
                        console.error("✗ Logo link init failed:", e);
                        // Non-critical, don't throw
                    }

                    console.log("✓ CloudWash UI fully initialized");

                } catch (error) {
                    console.error("Initialization Error:", error);
                    console.error("Error stack:", error.stack);
                }
            }, 100); // 100ms delay to ensure WebView2 backend is ready
        });

        // ============================================================================
        // PRESET SYSTEM (20 Presets)
        // ============================================================================
        const presets = {
            init: { position: 0.5, size: 0.5, pitch: 0, density: 0.5, texture: 0.5, feedback: 0, in_gain: 0.8, blend: 0.5, spread: 0, reverb: 0, quality: 0, mode: 0, freeze: false, blend_mode: 0 },
            cloud: { position: 0.7, size: 0.8, pitch: 0.01, density: 0.65, texture: 0.4, feedback: 0.3, in_gain: 0.8, blend: 0.7, spread: 0.9, reverb: 0.6, quality: 1, mode: 0, freeze: false, blend_mode: 0 },
            storm: { position: 0.2, size: 0.3, pitch: -0.5, density: 0.9, texture: 0.8, feedback: 0.1, in_gain: 0.9, blend: 0.8, spread: 0.4, reverb: 0.2, quality: 1, mode: 0, freeze: false, blend_mode: 0 },
            spectral: { position: 0.5, size: 0.6, pitch: 0, density: 0.7, texture: 0.3, feedback: 0, in_gain: 0.7, blend: 1.0, spread: 0.6, reverb: 0.5, quality: 0, mode: 3, freeze: false, blend_mode: 0 },
            lofi: { position: 0.4, size: 0.5, pitch: -0.2, density: 0.4, texture: 0.9, feedback: 0.4, in_gain: 0.8, blend: 0.6, spread: 0.2, reverb: 0.3, quality: 3, mode: 0, freeze: false, blend_mode: 0 },
            frozen: { position: 0.5, size: 0.7, pitch: 0, density: 0.3, texture: 0.5, feedback: 0.5, in_gain: 0.8, blend: 0.9, spread: 0.5, reverb: 0.7, quality: 0, mode: 0, freeze: true, blend_mode: 0 },
            reverse: { position: 0.3, size: 0.6, pitch: 0, density: 0.6, texture: 0.4, feedback: 0.6, in_gain: 0.8, blend: 0.7, spread: 0.3, reverb: 0.4, quality: 1, mode: 0, freeze: false, blend_mode: 0 },
            shimmer: { position: 0.8, size: 0.9, pitch: 1.0, density: 0.5, texture: 0.2, feedback: 0.2, in_gain: 0.7, blend: 0.6, spread: 1.0, reverb: 0.9, quality: 0, mode: 0, freeze: false, blend_mode: 0 },
            glitch: { position: 0.1, size: 0.1, pitch: -0.4, density: 0.95, texture: 1.0, feedback: 0, in_gain: 1.0, blend: 0.9, spread: 0.1, reverb: 0.1, quality: 3, mode: 0, freeze: false, blend_mode: 0 },
            pitchshift: { position: 0.5, size: 0.4, pitch: 0.25, density: 0.5, texture: 0.5, feedback: 0, in_gain: 0.8, blend: 1.0, spread: 0, reverb: 0, quality: 0, mode: 1, freeze: false, blend_mode: 0 },
            loop: { position: 0.5, size: 0.5, pitch: 0, density: 0.6, texture: 0.5, feedback: 0.7, in_gain: 0.8, blend: 0.5, spread: 0.5, reverb: 0.3, quality: 1, mode: 2, freeze: false, blend_mode: 2 }, // Feedback blend mode
            ambient: { position: 0.6, size: 0.85, pitch: 0, density: 0.45, texture: 0.3, feedback: 0.4, in_gain: 0.7, blend: 0.8, spread: 0.8, reverb: 0.8, quality: 0, mode: 0, freeze: false, blend_mode: 0 },
            octup: { position: 0.5, size: 0.3, pitch: 1.0, density: 0.5, texture: 0.5, feedback: 0, in_gain: 0.8, blend: 0.8, spread: 0, reverb: 0.1, quality: 0, mode: 1, freeze: false, blend_mode: 0 },
            octdown: { position: 0.5, size: 0.3, pitch: -1.0, density: 0.5, texture: 0.5, feedback: 0, in_gain: 0.8, blend: 0.8, spread: 0, reverb: 0.1, quality: 0, mode: 1, freeze: false, blend_mode: 0 },
            specfreeze: { position: 0.5, size: 0.5, pitch: 0, density: 0.8, texture: 0.6, feedback: 0, in_gain: 0.7, blend: 1.0, spread: 0.7, reverb: 0.6, quality: 0, mode: 3, freeze: true, blend_mode: 0 },
            dense: { position: 0.4, size: 0.4, pitch: -0.04, density: 0.85, texture: 0.75, feedback: 0.3, in_gain: 0.85, blend: 0.75, spread: 0.6, reverb: 0.4, quality: 1, mode: 0, freeze: false, blend_mode: 0 },
            sparse: { position: 0.6, size: 0.8, pitch: 0, density: 0.2, texture: 0.6, feedback: 0.2, in_gain: 0.8, blend: 0.65, spread: 0.5, reverb: 0.5, quality: 0, mode: 0, freeze: false, blend_mode: 0 },
            cascade: { position: 0.3, size: 0.5, pitch: -0.3, density: 0.7, texture: 0.5, feedback: 0.8, in_gain: 0.8, blend: 0.7, spread: 0.4, reverb: 0.5, quality: 1, mode: 2, freeze: false, blend_mode: 2 }, // Feedback blend mode
            resonant: { position: 0.5, size: 0.6, pitch: 0, density: 0.6, texture: 0.4, feedback: 0.9, in_gain: 0.8, blend: 0.6, spread: 0.3, reverb: 0.2, quality: 0, mode: 2, freeze: false, blend_mode: 2 }, // Feedback blend mode
            chaos: { position: 0.15, size: 0.2, pitch: 0.1, density: 1.0, texture: 0.95, feedback: 0.5, in_gain: 0.9, blend: 0.85, spread: 0.7, reverb: 0.3, quality: 3, mode: 0, freeze: false, blend_mode: 0 }
        };

        function initializePresets() {
            const select = document.getElementById('presetSelect');
            const freezeButton = document.getElementById('freezeButton');

            select.addEventListener('change', (e) => {
                const preset = presets[e.target.value];
                if (!preset) return;

                console.log(`Applying preset: ${e.target.value}`);

                // Apply all parameters
                for (const [key, value] of Object.entries(preset)) {
                    // Handle mode switching
                    if (key === 'mode') {
                        const tab = document.querySelector(`.mode-tab[data-mode="${value}"]`);
                        if (tab) tab.click();
                        continue;
                    }

                    // Handle freeze toggle
                    if (key === 'freeze') {
                        const toggleState = window.Juce ? window.Juce.getToggleState('freeze') : null;
                        if (toggleState) {
                            toggleState.setValue(value);
                        } else if (freezeButton) {
                            freezeButton.classList.toggle('active', value);
                            document.getElementById('freezeLED').classList.toggle('active', value);
                        }
                        continue;
                    }

                    // Handle blend mode switching
                    if (key === 'blend_mode') {
                        const blendModeSelect = document.getElementById('blendModeSelect');
                        if (blendModeSelect) {
                            blendModeSelect.value = value;
                            blendModeSelect.dispatchEvent(new Event('change'));
                        }
                        continue;
                    }

                    const el = document.querySelector(`[data-param="${key}"]`);
                    if (!el) continue;

                    if (el.tagName === 'SELECT') {
                        el.value = value;
                        el.dispatchEvent(new Event('change'));
                    } else if (el.classList.contains('knob')) {
                        const sliderState = window.Juce ? window.Juce.getSliderState(key) : null;
                        if (sliderState) {
                            // Convert scaled back to normalized for the UI update
                            const min = parseFloat(el.dataset.min);
                            const max = parseFloat(el.dataset.max);
                            const norm = (value - min) / (max - min);
                            sliderState.setNormalisedValue(norm);
                        }
                    }
                }

                // Reset dropdown to placeholder after applying
                setTimeout(() => { select.selectedIndex = 0; }, 100);
            });
        }

        function initializeKnobs() {
            const knobs = document.querySelectorAll('.knob');
            console.log(`Initializing ${knobs.length} knobs...`);

            const ARC_START = 120;
            const ARC_RANGE = 300;
            const KNOB_RADIUS = 31;

            knobs.forEach((knob, index) => {
                const paramName = knob.dataset.param;
                const min = parseFloat(knob.dataset.min);
                const max = parseFloat(knob.dataset.max);
                const defaultValue = parseFloat(knob.dataset.default);

                let isDragging = false;
                let startY = 0;
                let startNormalized = 0;

                const track = knob.querySelector('.knob-track');
                const arc = knob.querySelector('.knob-arc');
                const indicator = knob.querySelector('.knob-indicator');
                const valueDisplay = knob.parentElement.querySelector('.knob-value');

                // Create JUCE slider state for this parameter
                const sliderState = window.Juce ? window.Juce.getSliderState(paramName) : null;

                function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
                    const angleInRadians = angleInDegrees * Math.PI / 180.0;
                    return {
                        x: centerX + (radius * Math.cos(angleInRadians)),
                        y: centerY + (radius * Math.sin(angleInRadians))
                    };
                }

                function describeArc(x, y, radius, startAngle, endAngle) {
                    const start = polarToCartesian(x, y, radius, endAngle);
                    const end = polarToCartesian(x, y, radius, startAngle);
                    const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
                    return `M ${start.x} ${start.y} A ${radius} ${radius} 0 ${largeArcFlag} 0 ${end.x} ${end.y}`;
                }

                function updateVisualFromValue(value) {
                    const normalized = (value - min) / (max - min);

                    // Draw track
                    const trackPath = describeArc(35, 35, KNOB_RADIUS, ARC_START, ARC_START + ARC_RANGE);
                    track.setAttribute('d', trackPath);

                    // Draw arc
                    const endAngle = ARC_START + (ARC_RANGE * normalized);
                    const arcPath = describeArc(35, 35, KNOB_RADIUS, ARC_START, endAngle);
                    arc.setAttribute('d', arcPath);

                    // Position indicator
                    const angle = (ARC_START + (ARC_RANGE * normalized)) * Math.PI / 180;
                    const indicatorX = 35 + KNOB_RADIUS * Math.cos(angle) - 3.5;
                    const indicatorY = 35 + KNOB_RADIUS * Math.sin(angle) - 3.5;
                    indicator.style.left = `${indicatorX}px`;
                    indicator.style.top = `${indicatorY}px`;

                    // Update value display and visualization
                    if (paramName === 'pitch') {
                        valueDisplay.textContent = value >= 0 ? `+${value.toFixed(2)}` : value.toFixed(2);
                    } else if (paramName === 'density') {
                        // Density: show as +/- percentage from center (50%)
                        const densityOffset = (value - 0.5) * 200; // -100% to +100%
                        if (Math.abs(densityOffset) < 1) {
                            valueDisplay.textContent = "0%";
                        } else {
                            valueDisplay.textContent = (densityOffset >= 0 ? "+" : "") + densityOffset.toFixed(0) + "%";
                        }
                        // Update visualization
                        updateDensityVisualization(value);
                    } else {
                        valueDisplay.textContent = `${Math.round(normalized * 100)}%`;
                    }

                    // Update visualization for all parameters
                    if (window.updateVisualizationParams) {
                        const params = {};
                        params[paramName] = value;
                        window.updateVisualizationParams(params);
                    }
                }

                // Listen for parameter changes from JUCE (automation, preset load, etc.)
                if (sliderState) {
                    sliderState.addValueChangedListener(() => {
                        const value = sliderState.getScaledValue();
                        updateVisualFromValue(value);
                    });
                }

                // Mouse drag handling
                knob.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    isDragging = true;
                    startY = e.clientY;

                    if (sliderState) {
                        startNormalized = sliderState.getNormalisedValue();
                        sliderState.sliderDragStarted();
                    } else {
                        startNormalized = (defaultValue - min) / (max - min);
                    }

                    knob.classList.add('active');
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaY = startY - e.clientY;
                        const sensitivity = 0.005;
                        const range = max - min;
                        const deltaNormalized = deltaY * sensitivity;
                        let newNormalized = startNormalized + deltaNormalized;
                        newNormalized = Math.max(0, Math.min(1, newNormalized));

                        if (sliderState) {
                            // Send to JUCE backend
                            sliderState.setNormalisedValue(newNormalized);
                        } else {
                            // Standalone mode - just update visuals
                            const newValue = min + newNormalized * range;
                            updateVisualFromValue(newValue);
                        }
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        knob.classList.remove('active');

                        if (sliderState) {
                            sliderState.sliderDragEnded();
                        }
                    }
                });

                // Double-click to reset
                knob.addEventListener('dblclick', () => {
                    const normalizedDefault = (defaultValue - min) / (max - min);
                    if (sliderState) {
                        sliderState.setNormalisedValue(normalizedDefault);
                    } else {
                        updateVisualFromValue(defaultValue);
                    }
                });

                // Initialize visual from JUCE state or default
                if (sliderState) {
                    const initialValue = sliderState.getScaledValue();
                    updateVisualFromValue(initialValue);
                } else {
                    updateVisualFromValue(defaultValue);
                }

                console.log(`  ✓ ${paramName}`);
            });
        }

        function initializeModeTabs() {
            try {
                const modeTabs = document.querySelectorAll('.mode-tab');
                console.log(`Initializing ${modeTabs.length} mode tabs...`);

                const sliderState = window.Juce ? window.Juce.getSliderState('mode') : null;

                // Handle user clicks
                modeTabs.forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        console.log(`Tab clicked: ${tab.dataset.mode}`);
                        const modeIndex = parseInt(tab.dataset.mode);

                        if (sliderState) {
                            sliderState.setNormalisedValue(modeIndex / 3.0);
                        } else {
                            // Standalone mode visual backup
                            modeTabs.forEach(t => t.classList.remove('active'));
                            tab.classList.add('active');
                        }
                    });
                });

                // Listen for mode changes from JUCE
                if (sliderState) {
                    sliderState.addValueChangedListener(() => {
                        const normalizedValue = sliderState.getNormalisedValue();
                        const modeIndex = Math.round(normalizedValue * 3.0);
                        console.log(`Mode updated from JUCE: ${modeIndex}`);
                        modeTabs.forEach((tab, idx) => {
                            tab.classList.toggle('active', idx === modeIndex);
                        });
                    });

                    // Initial state
                    const initialValue = sliderState.getNormalisedValue();
                    const initialMode = Math.round(initialValue * 3.0);
                    modeTabs.forEach((tab, idx) => {
                        tab.classList.toggle('active', idx === initialMode);
                    });
                }

                console.log("✓ Mode tabs fully initialized");
            } catch (err) {
                console.error("Failed to initialize mode tabs:", err);
            }
        }

        function initializeFreezeButton() {
            const freezeButton = document.getElementById('freezeButton');
            const freezeLED = document.getElementById('freezeLED');
            const toggleState = window.Juce ? window.Juce.getToggleState('freeze') : null;

            // Listen for freeze changes from JUCE
            if (toggleState) {
                toggleState.addValueChangedListener(() => {
                    const isActive = toggleState.getValue();
                    freezeActive = isActive;
                    freezeButton.classList.toggle('active', isActive);
                    freezeLED.classList.toggle('active', isActive);
                });
            }

            // Handle user clicks
            freezeButton.addEventListener('click', () => {
                if (toggleState) {
                    const newValue = !toggleState.getValue();
                    toggleState.setValue(newValue);
                } else {
                    // Standalone mode
                    const isActive = freezeButton.classList.contains('active');
                    freezeActive = !isActive;
                    freezeButton.classList.toggle('active', freezeActive);
                    freezeLED.classList.toggle('active', freezeActive);
                }
            });

            // Initialize from JUCE state
            if (toggleState) {
                const initialValue = toggleState.getValue();
                freezeActive = initialValue;
                freezeButton.classList.toggle('active', initialValue);
                freezeLED.classList.toggle('active', initialValue);
            }

            console.log("✓ Freeze button");
        }

        function initializeDropdowns() {
            const qualitySelect = document.getElementById('qualitySelect');
            const blendModeSelect = document.getElementById('blendModeSelect');

            if (!qualitySelect) {
                console.error("Quality dropdown not found in HTML!");
                return;
            }

            // Quality dropdown
            const qualityState = window.Juce ? window.Juce.getSliderState('quality') : null;
            if (qualityState) {
                qualityState.addValueChangedListener(() => {
                    const normalized = qualityState.getNormalisedValue();
                    if (qualitySelect) qualitySelect.selectedIndex = Math.round(normalized * 4.0); // 0-4 for 5 options
                });

                qualitySelect.addEventListener('change', () => {
                    qualityState.setNormalisedValue(qualitySelect.selectedIndex / 4.0); // 0-4 for 5 options
                });

                // Initialize
                qualitySelect.selectedIndex = Math.round(qualityState.getNormalisedValue() * 4.0);
            } else {
                qualitySelect.addEventListener('change', () => {
                    console.log('Quality changed (standalone):', qualitySelect.value);
                });
            }

            // Note: Blend Mode dropdown removed - blend parameters are controlled directly by their respective knobs
            // (Blend, Spread, Feedback, Reverb) in the main control grid
            // The sample_mode parameter exists but we don't have a UI control for it

            console.log("✓ Dropdowns");
        }

        function initializeMeters() {
            const inputMeter = document.getElementById('inputMeter');
            const outputMeter = document.getElementById('outputMeter');

            function createMeterSegments(meter) {
                for (let i = 0; i < 24; i++) {
                    const segment = document.createElement('div');
                    segment.className = 'meter-segment';
                    meter.appendChild(segment);
                }
            }

            createMeterSegments(inputMeter);
            createMeterSegments(outputMeter);

            function updateMeter(meter, level) {
                // Validate input level is within [0, 1] range to prevent display issues
                const clampedLevel = Math.max(0, Math.min(1, level));
                const segments = meter.querySelectorAll('.meter-segment');
                const activeSegments = Math.floor(clampedLevel * 24);

                segments.forEach((segment, index) => {
                    segment.classList.remove('active', 'green', 'yellow', 'red');
                    if (index < activeSegments) {
                        segment.classList.add('active');
                        if (index < 19) segment.classList.add('green');
                        else if (index < 23) segment.classList.add('yellow');
                        else segment.classList.add('red');
                    }
                });
            }

            // ============================================================
            // METER UPDATE: Connected to Real Audio
            // ============================================================
            // Global function called from C++ (via evaluateJavascript)
            // Called at 30 Hz from PluginEditor::timerCallback()
            window.updateMeters = function (inputLevel, outputLevel) {
                updateMeter(inputMeter, inputLevel);
                updateMeter(outputMeter, outputLevel);
            };

            console.log("✓ Meters (connected to real audio levels)");
        }

        // ============================================================
        // GRAIN VISUALIZATION - UNIFIED WINDOW WITH PARAMETER RESPONSE
        // All knobs affect the visualization in meaningful ways
        // ============================================================
        let currentDensityValue = 0.5; // Start at center (50%)
        let currentTextureValue = 0.5;
        let currentReverbValue = 0;
        let currentSpreadValue = 0;
        let currentSizeValue = 0.5;
        let currentFeedbackValue = 0;
        let freezeActive = false;

        function updateDensityVisualization(densityValue) {
            currentDensityValue = densityValue;
        }

        function initializeGrainVisualization() {
            const canvas = document.getElementById('grainCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 680;
            canvas.height = 60;

            const MAX_PARTICLES = 50;
            const particles = [];

            // Initialize single particle pool for unified visualization
            for (let i = 0; i < MAX_PARTICLES; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.3,
                    size: 2 + Math.random() * 3,
                    opacity: 0.3 + Math.random() * 0.3,
                    active: false,
                    // For reverb tail effect
                    trail: []
                });
            }

            // Track parameter values from knobs
            const paramValues = {
                density: 0.5,
                texture: 0.5,
                reverb: 0,
                spread: 0,
                size: 0.5,
                feedback: 0
            };

            // Update parameter values when knobs change
            window.updateVisualizationParams = function(params) {
                if (params.density !== undefined) {
                    paramValues.density = params.density;
                    currentDensityValue = params.density;
                }
                if (params.texture !== undefined) paramValues.texture = params.texture;
                if (params.reverb !== undefined) {
                    paramValues.reverb = params.reverb;
                    currentReverbValue = params.reverb;
                }
                if (params.spread !== undefined) {
                    paramValues.spread = params.spread;
                    currentSpreadValue = params.spread;
                }
                if (params.size !== undefined) {
                    paramValues.size = params.size;
                    currentSizeValue = params.size;
                }
                if (params.feedback !== undefined) {
                    paramValues.feedback = params.feedback;
                    currentFeedbackValue = params.feedback;
                }
            };

            // Called from C++ at 30 Hz with real grain data
            window.updateGrainVisualization = function (activeGrains, density, texture) {
                if (density !== undefined) {
                    currentDensityValue = density;
                    paramValues.density = density;
                }
                if (texture !== undefined) {
                    paramValues.texture = texture;
                    currentTextureValue = texture;
                }
            };

            function animateGrains() {
                // COMPLETE CLEAR - no trail tint left behind
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Calculate how "far" from center we are (0.0 to 1.0)
                // 50% = 0, 0% or 100% = 1.0
                const distanceFromCenter = Math.abs(currentDensityValue - 0.5) * 2;

                // Calculate number of active particles based on distance from center
                const activeParticleCount = Math.floor(distanceFromCenter * MAX_PARTICLES);

                // Determine base velocity direction based on density
                // < 50% = move left, > 50% = move right
                const baseVelocityX = (currentDensityValue - 0.5) * 4; // -2 to +2

                // Texture affects particle roughness/jitter and size variation
                const textureRoughness = paramValues.texture * 2.0;
                const sizeVariation = 1.0 + paramValues.texture * 3.0;

                // Reverb affects glow and trail length
                const reverbGlow = paramValues.reverb * 20;
                const trailLength = Math.floor(paramValues.reverb * 8);

                // Spread affects vertical movement
                const spreadAmount = paramValues.spread * 2.0;

                // Size affects particle base size
                const baseSizeMultiplier = 0.5 + paramValues.size * 2.0;

                // Feedback affects opacity and persistence
                const opacityBoost = paramValues.feedback * 0.4;

                // Update and draw particles
                particles.forEach((p, index) => {
                    // Activate particles based on density distance from center
                    p.active = index < activeParticleCount;

                    if (!p.active) return;

                    if (!freezeActive) {
                        // Store position for trail
                        if (trailLength > 0) {
                            p.trail.push({ x: p.x, y: p.y });
                            if (p.trail.length > trailLength) {
                                p.trail.shift();
                            }
                        } else {
                            p.trail = [];
                        }

                        // Apply velocity with texture-based jitter
                        const jitterX = (Math.random() - 0.5) * textureRoughness;
                        const jitterY = (Math.random() - 0.5) * textureRoughness;

                        p.x += baseVelocityX + jitterX;
                        p.y += p.vy * spreadAmount + jitterY;

                        // Wrap around edges
                        if (baseVelocityX > 0 && p.x > canvas.width + 10) {
                            p.x = -10;
                            p.y = Math.random() * canvas.height;
                            p.trail = [];
                        } else if (baseVelocityX < 0 && p.x < -10) {
                            p.x = canvas.width + 10;
                            p.y = Math.random() * canvas.height;
                            p.trail = [];
                        } else if (baseVelocityX === 0) {
                            // At center (50%), particles drift randomly
                            if (p.x < -10) p.x = canvas.width + 10;
                            if (p.x > canvas.width + 10) p.x = -10;
                        }

                        if (p.y < 0) p.y = canvas.height;
                        if (p.y > canvas.height) p.y = 0;
                    }

                    // Calculate display properties
                    const displaySize = p.size * baseSizeMultiplier * (1 + Math.random() * sizeVariation * 0.3);
                    const displayOpacity = Math.min(0.9, p.opacity + opacityBoost);

                    // Color based on texture - smooth = cyan, rough = teal/white
                    const hue = 185 - paramValues.texture * 25; // 185 (cyan) to 160 (teal)
                    const saturation = 70 - paramValues.texture * 30; // 70% to 40%
                    const lightness = 65 + paramValues.texture * 15; // 65% to 80%

                    // Draw trail (reverb effect)
                    if (p.trail.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(p.trail[0].x, p.trail[0].y);
                        for (let i = 1; i < p.trail.length; i++) {
                            ctx.lineTo(p.trail[i].x, p.trail[i].y);
                        }
                        ctx.strokeStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${displayOpacity * 0.3})`;
                        ctx.lineWidth = displaySize * 0.5;
                        ctx.stroke();
                    }

                    // Draw particle with glow
                    ctx.shadowBlur = reverbGlow;
                    ctx.shadowColor = `hsla(${hue}, ${saturation}%, ${lightness}%, ${displayOpacity * 0.5})`;
                    ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${displayOpacity})`;

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, displaySize, 0, Math.PI * 2);
                    ctx.fill();

                    // Reset shadow for next particle
                    ctx.shadowBlur = 0;
                });

                requestAnimationFrame(animateGrains);
            }

            animateGrains();
            console.log("✓ Grain visualization (unified window, all parameters affect visuals)");
        }

        // ============================================================================
        // GLOBAL DEBUG FUNCTION (call from console: testBackend())
        // ============================================================================
        window.testBackend = function() {
            console.log("=== JUCE Backend Test ===");
            console.log("window.__JUCE__ exists:", typeof window.__JUCE__ !== 'undefined');

            if (window.__JUCE__) {
                console.log("window.__JUCE__.backend exists:", typeof window.__JUCE__.backend !== 'undefined');
                console.log("window.__JUCE__ contents:", window.__JUCE__);

                if (window.__JUCE__.backend) {
                    console.log("✓ Backend is connected!");

                    // Try to create a test slider
                    try {
                        const testSlider = window.Juce.getSliderState('position');
                        console.log("Test slider created:", testSlider);
                        console.log("Current value:", testSlider.getScaledValue());
                    } catch (e) {
                        console.error("Error creating test slider:", e);
                    }
                } else {
                    console.error("✗ window.__JUCE__ exists but .backend is missing");
                }
            } else {
                console.error("✗ window.__JUCE__ does not exist");
                console.log("This means WebView native integration is not working");
            }

            // Also test if relays are registered
            console.log("\nParameter Relays:");
            console.log("  positionRelay ID:", window.positionRelay?.identifier || "NOT FOUND");

            return "Test complete - check logs above";
        };

        // Show debug message on load
        console.log("💡 Type testBackend() in console to check JUCE connection");
    </script>
</body>

</html>