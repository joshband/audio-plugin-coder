<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CloudWash - Granular Texture Processor</title>
    <style>
        :root {
            --bg-primary: #1A1A2E;
            --bg-surface: #2A2A3E;
            --bg-raised: #3A3A4E;
            --brand-teal: #427E88;
            --brand-cyan: #5AC8D8;
            --text-primary: #FFFFFF;
            --text-secondary: #A0A0B0;
            --text-muted: #707085;
            --color-active: #427E88;
            --color-success: #4CAF50;
            --color-warning: #FFC107;
            --color-danger: #FF4444;
            --viz-top: #3A4A6E;
            --viz-bottom: #1A1A2E;
            --glow-teal: rgba(66, 126, 136, 0.4);
            --font-primary: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-primary);
            background: var(--bg-primary);
            color: var(--text-primary);
            width: 800px;
            height: 500px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            user-select: none;
        }


        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px;
            background: var(--bg-primary);
        }

        .plugin-title {
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 2px;
            color: var(--text-primary);
        }

        .mode-tabs {
            display: flex;
            gap: 2px;
            background: var(--bg-surface);
            border-radius: 6px;
            padding: 2px;
        }

        .mode-tab {
            width: 100px;
            height: 32px;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 200ms ease-in-out;
        }

        .mode-tab:hover {
            background: var(--bg-raised);
        }

        .mode-tab.active {
            background: var(--brand-teal);
            box-shadow: 0 2px 8px var(--glow-teal);
        }

        .grain-visualization {
            width: calc(100% - 60px);
            height: 60px;
            margin: 0 30px 15px 30px;
            background: linear-gradient(to bottom, var(--viz-top), var(--viz-bottom));
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        #grainCanvas {
            width: 100%;
            height: 100%;
        }

        .controls-wrapper {
            flex: 1;
            display: flex;
            padding: 0 30px;
            gap: 15px;
        }

        .left-meter-container,
        .right-meter-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .controls-center {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px 18px;
        }

        .knob-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .knob-label {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        .knob {
            width: 70px;
            height: 70px;
            cursor: ns-resize;
            position: relative;
        }

        .knob:hover .knob-arc {
            filter: drop-shadow(0 0 8px var(--glow-teal));
        }

        .knob.active .knob-arc {
            filter: drop-shadow(0 0 12px var(--glow-teal));
        }

        .knob-track {
            fill: none;
            stroke: var(--bg-surface);
            stroke-width: 6;
            stroke-linecap: round;
        }

        .knob-arc {
            fill: none;
            stroke: var(--brand-teal);
            stroke-width: 6;
            stroke-linecap: round;
            /* NO transition - causes glitchy/jumpy rendering during drag */
        }

        .knob-arc.pitch {
            stroke: var(--brand-cyan);
        }

        .knob-marker {
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 6px;
            background: var(--text-muted);
            border-radius: 1px;
            opacity: 0.6;
        }

        .knob-indicator {
            width: 7px;
            height: 7px;
            background: var(--text-primary);
            border-radius: 50%;
            position: absolute;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }

        .knob-value {
            font-size: 12px;
            font-weight: 400;
            color: var(--text-secondary);
            font-variant-numeric: tabular-nums;
        }

        .meter-label {
            font-size: 9px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .meter {
            width: 32px;
            height: 240px;
            background: var(--bg-surface);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column-reverse;
        }

        .meter-segment {
            width: 100%;
            height: 4.17%;
            background: var(--bg-raised);
            margin-top: 1px;
            transition: background 20ms ease;
        }

        .meter-segment.active.green {
            background: var(--color-success);
            box-shadow: 0 0 3px var(--color-success);
        }

        .meter-segment.active.yellow {
            background: var(--color-warning);
            box-shadow: 0 0 3px var(--color-warning);
        }

        .meter-segment.active.red {
            background: var(--color-danger);
            box-shadow: 0 0 4px var(--color-danger);
        }

        .footer {
            padding: 0 30px 12px 30px;
            display: flex;
            justify-content: center;
        }

        .footer-container {
            background: var(--bg-surface);
            border: 1px solid var(--bg-raised);
            border-radius: 8px;
            padding: 10px 14px;
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .dropdown {
            width: 95px;
            height: 30px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-raised);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 10px;
            padding: 0 10px;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23A0A0B0' d='M2 4l4 4 4-4z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
        }

        .dropdown:hover {
            background: var(--bg-surface);
            border-color: var(--brand-teal);
        }

        .freeze-button {
            width: 140px;
            height: 36px;
            background: var(--bg-raised);
            border: 2px solid var(--bg-surface);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 150ms ease;
        }

        .freeze-button:hover {
            background: var(--bg-surface);
            border-color: var(--brand-teal);
        }

        .freeze-button.active {
            background: var(--brand-teal);
            border-color: var(--brand-cyan);
            box-shadow: 0 4px 12px var(--glow-teal);
        }

        .freeze-led {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--bg-surface);
            border: 2px solid var(--bg-raised);
            transition: all 150ms ease;
        }

        .freeze-led.active {
            background: var(--color-danger);
            border-color: var(--color-danger);
            box-shadow: 0 0 8px var(--color-danger), 0 0 16px rgba(255, 68, 68, 0.4);
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.6;
            }

            50% {
                opacity: 1.0;
            }
        }

        /* DEBUG OVERLAY */
        .debug-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            font-family: monospace;
            font-size: 11px;
            z-index: 10000;
            display: none;
            border-bottom: 2px solid #ff4444;
        }

        .debug-overlay.active {
            display: block;
        }

        .debug-overlay.connected {
            border-bottom-color: #44ff44;
        }

        .debug-status {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .debug-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4444;
        }

        .debug-indicator.connected {
            background: #44ff44;
        }
    </style>
</head>

<body>
    <!-- DEBUG OVERLAY -->
    <div class="debug-overlay active" id="debugOverlay">
        <div class="debug-status">
            <div class="debug-indicator" id="debugIndicator"></div>
            <span id="debugMessage">Initializing...</span>
        </div>
    </div>

    <div class="header">
        <div class="plugin-title">CLOUDWASH</div>
        <div class="mode-tabs">
            <button class="mode-tab active" data-mode="0">GRANULAR</button>
            <button class="mode-tab" data-mode="1">PITCH</button>
            <button class="mode-tab" data-mode="2">DELAY</button>
            <button class="mode-tab" data-mode="3">SPECTRAL</button>
        </div>
    </div>

    <div class="grain-visualization">
        <canvas id="grainCanvas"></canvas>
    </div>

    <div class="controls-wrapper">
        <div class="left-meter-container">
            <div class="meter-label">IN</div>
            <div class="meter" id="inputMeter"></div>
        </div>

        <div class="controls-center">
            <div class="controls-grid">
                <!-- ROW 1 -->
                <div class="knob-container">
                    <div class="knob-label">POSITION</div>
                    <div class="knob" data-param="position" data-min="0" data-max="1" data-default="0.5">
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">50%</div>
                </div>

                <div class="knob-container">
                    <div class="knob-label">TEXTURE</div>
                    <div class="knob" data-param="texture" data-min="0" data-max="1" data-default="0.5">
                        <div class="knob-marker"></div>
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">50%</div>
                </div>

                <div class="knob-container">
                    <div class="knob-label">PITCH</div>
                    <div class="knob" data-param="pitch" data-min="-2" data-max="2" data-default="0">
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc pitch" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">+0.00</div>
                </div>

                <div class="knob-container">
                    <div class="knob-label">DENSITY</div>
                    <div class="knob" data-param="density" data-min="0" data-max="1" data-default="0.5">
                        <div class="knob-marker"></div>
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">50%</div>
                </div>

                <div class="knob-container">
                    <div class="knob-label">FEEDBACK</div>
                    <div class="knob" data-param="feedback" data-min="0" data-max="1" data-default="0">
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">0%</div>
                </div>

                <!-- ROW 2 -->
                <div class="knob-container">
                    <div class="knob-label">SIZE</div>
                    <div class="knob" data-param="size" data-min="0" data-max="1" data-default="0.5">
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">50%</div>
                </div>

                <div class="knob-container">
                    <div class="knob-label">IN GAIN</div>
                    <div class="knob" data-param="in_gain" data-min="0" data-max="1" data-default="0.8">
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">80%</div>
                </div>

                <div class="knob-container">
                    <div class="knob-label">BLEND</div>
                    <div class="knob" data-param="blend" data-min="0" data-max="1" data-default="0.5">
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">50%</div>
                </div>

                <div class="knob-container">
                    <div class="knob-label">SPREAD</div>
                    <div class="knob" data-param="spread" data-min="0" data-max="1" data-default="0">
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">0%</div>
                </div>

                <div class="knob-container">
                    <div class="knob-label">REVERB</div>
                    <div class="knob" data-param="reverb" data-min="0" data-max="1" data-default="0">
                        <svg width="70" height="70" viewBox="0 0 70 70">
                            <path class="knob-track" />
                            <path class="knob-arc" />
                        </svg>
                        <div class="knob-indicator"></div>
                    </div>
                    <div class="knob-value">0%</div>
                </div>
            </div>
        </div>

        <div class="right-meter-container">
            <div class="meter-label">OUT</div>
            <div class="meter" id="outputMeter"></div>
        </div>
    </div>

    <div class="footer">
        <div class="footer-container">
            <select class="dropdown" id="presetSelect" style="width: 160px;">
                <option value="" disabled selected>Select Preset</option>
                <option value="init">01 - Init</option>
                <option value="cloud">02 - Ethereal Cloud</option>
                <option value="storm">03 - Grain Storm</option>
                <option value="spectral">04 - Spectral Wash</option>
                <option value="lofi">05 - Lo-Fi Dream</option>
                <option value="frozen">06 - Frozen Moment</option>
                <option value="reverse">07 - Reverse Echo</option>
                <option value="shimmer">08 - Shimmer Verb</option>
                <option value="glitch">09 - Glitch Machine</option>
                <option value="pitchshift">10 - Pitch Shifter</option>
                <option value="loop">11 - Looping Delay</option>
                <option value="ambient">12 - Ambient Pad</option>
                <option value="octup">13 - Octave Up</option>
                <option value="octdown">14 - Octave Down</option>
                <option value="specfreeze">15 - Spectral Freeze</option>
                <option value="dense">16 - Dense Texture</option>
                <option value="sparse">17 - Sparse Grains</option>
                <option value="cascade">18 - Pitch Cascade</option>
                <option value="resonant">19 - Resonant Delay</option>
                <option value="chaos">20 - Granular Chaos</option>
            </select>
            <select class="dropdown" id="qualitySelect" data-param="quality">
                <option value="0">Hi-Fi Stereo (1s)</option>
                <option value="1">Hi-Fi Mono (2s)</option>
                <option value="2">Lo-Fi Stereo (4s)</option>
                <option value="3">Lo-Fi Mono (8s)</option>
                <option value="4" selected>Ultra HQ (Long)</option>
            </select>
            <select class="dropdown" id="blendModeSelect" data-param="blend_mode">
                <option value="0" selected>Blend: Wet/Dry</option>
                <option value="1">Blend: Spread</option>
                <option value="2">Blend: Feedback</option>
                <option value="3">Blend: Reverb</option>
            </select>
            <button class="freeze-button" id="freezeButton" data-param="freeze">FREEZE</button>
            <div class="freeze-led" id="freezeLED"></div>
        </div>
    </div>

    <!-- Inline JavaScript - No CORS issues -->
    <!--
        JUCE LIBRARY IMPLEMENTATION NOTE:
        This inline JUCE library implementation is the ACTIVE version used by the plugin.
        There is a duplicate ES6 module version in js/index.js which is NOT used.
        
        The inline version is more complete and has better error handling.
        When making changes to JUCE bindings, update this inline version.
        
        The js/index.js file is kept for reference but is not loaded by the plugin.
        See PluginEditor.cpp which loads resources via the resource provider.
    -->
    <script>
        // ============================================================================
        // JUCE LIBRARY (INLINED) - Simplified for CloudWash
        // ============================================================================
        (function () {
            'use strict';

            try {
                // Check if JUCE backend is available (with retry for WebView2 initialization)
                let isJuceAvailable = typeof window.__JUCE__ !== 'undefined';

                if (!isJuceAvailable) {
                    console.warn("JUCE backend not immediately available - will retry after page load");
                    // Don't return immediately - we'll check again in DOMContentLoaded
                } else {
                    console.log("JUCE backend detected immediately - initializing parameter bindings");
                }

                // Global JUCE API object
                window.Juce = window.Juce || {};

            // Slider State Management
            class SliderState {
                constructor(name) {
                    this.name = name;
                    this.identifier = "__juce__slider" + name;
                    this.scaledValue = 0;
                    this.properties = {
                        start: 0,
                        end: 1,
                        skew: 1,
                        name: "",
                        label: "",
                        numSteps: 100,
                        interval: 0,
                        parameterIndex: -1,
                    };
                    this.valueChangedListeners = [];

                    if (window.__JUCE__ && window.__JUCE__.backend) {
                        window.__JUCE__.backend.addEventListener(this.identifier, (event) => this.handleEvent(event));
                        window.__JUCE__.backend.emitEvent(this.identifier, { eventType: "requestInitialUpdate" });
                    }
                }

                setNormalisedValue(newValue) {
                    this.scaledValue = this.snapToLegalValue(this.normalisedToScaledValue(newValue));
                    if (window.__JUCE__ && window.__JUCE__.backend) {
                        window.__JUCE__.backend.emitEvent(this.identifier, {
                            eventType: "valueChanged",
                            value: this.scaledValue
                        });
                    }
                }

                sliderDragStarted() {
                    if (window.__JUCE__ && window.__JUCE__.backend) {
                        window.__JUCE__.backend.emitEvent(this.identifier, {
                            eventType: "sliderDragStarted"
                        });
                    }
                }

                sliderDragEnded() {
                    if (window.__JUCE__ && window.__JUCE__.backend) {
                        window.__JUCE__.backend.emitEvent(this.identifier, {
                            eventType: "sliderDragEnded"
                        });
                    }
                }

                handleEvent(event) {
                    if (event.eventType === "valueChanged") {
                        this.scaledValue = event.value;
                        this.valueChangedListeners.forEach(fn => fn());
                    }
                    if (event.eventType === "propertiesChanged") {
                        const { eventType, ...rest } = event;
                        this.properties = rest;
                    }
                }

                getScaledValue() {
                    return this.scaledValue;
                }

                getNormalisedValue() {
                    return Math.pow(
                        (this.scaledValue - this.properties.start) / (this.properties.end - this.properties.start),
                        this.properties.skew
                    );
                }

                normalisedToScaledValue(normalisedValue) {
                    return Math.pow(normalisedValue, 1 / this.properties.skew) *
                        (this.properties.end - this.properties.start) + this.properties.start;
                }

                snapToLegalValue(value) {
                    const interval = this.properties.interval;
                    if (interval === 0) return value;

                    const start = this.properties.start;
                    const clamp = (val, min = 0, max = 1) => Math.max(min, Math.min(max, val));
                    return clamp(
                        start + interval * Math.floor((value - start) / interval + 0.5),
                        this.properties.start,
                        this.properties.end
                    );
                }

                addValueChangedListener(fn) {
                    this.valueChangedListeners.push(fn);
                }
            }

            // Toggle State Management
            class ToggleState {
                constructor(name) {
                    this.name = name;
                    this.identifier = "__juce__toggle" + name;
                    this.value = false;
                    this.valueChangedListeners = [];

                    if (window.__JUCE__ && window.__JUCE__.backend) {
                        window.__JUCE__.backend.addEventListener(this.identifier, (event) => this.handleEvent(event));
                        window.__JUCE__.backend.emitEvent(this.identifier, { eventType: "requestInitialUpdate" });
                    }
                }

                getValue() {
                    return this.value;
                }

                setValue(newValue) {
                    this.value = newValue;
                    if (window.__JUCE__ && window.__JUCE__.backend) {
                        window.__JUCE__.backend.emitEvent(this.identifier, {
                            eventType: "valueChanged",
                            value: this.value
                        });
                    }
                }

                handleEvent(event) {
                    if (event.eventType === "valueChanged") {
                        this.value = event.value;
                        this.valueChangedListeners.forEach(fn => fn());
                    }
                }

                addValueChangedListener(fn) {
                    this.valueChangedListeners.push(fn);
                }
            }

            // ComboBox State Management
            class ComboBoxState {
                constructor(name) {
                    this.name = name;
                    this.identifier = "__juce__comboBox" + name;
                    this.value = 0.0;
                    this.properties = {
                        name: "",
                        parameterIndex: -1,
                        choices: []
                    };
                    this.valueChangedListeners = [];

                    if (window.__JUCE__ && window.__JUCE__.backend) {
                        window.__JUCE__.backend.addEventListener(this.identifier, (event) => this.handleEvent(event));
                        window.__JUCE__.backend.emitEvent(this.identifier, { eventType: "requestInitialUpdate" });
                    }
                }

                getChoiceIndex() {
                    return Math.round(this.value * (this.properties.choices.length - 1));
                }

                setChoiceIndex(index) {
                    const numItems = this.properties.choices.length;
                    this.value = numItems > 1 ? index / (numItems - 1) : 0.0;

                    if (window.__JUCE__ && window.__JUCE__.backend) {
                        window.__JUCE__.backend.emitEvent(this.identifier, {
                            eventType: "valueChanged",
                            value: this.value
                        });
                    }
                }

                handleEvent(event) {
                    if (event.eventType === "valueChanged") {
                        this.value = event.value;
                        this.valueChangedListeners.forEach(fn => fn());
                    }
                    if (event.eventType === "propertiesChanged") {
                        const { eventType, ...rest } = event;
                        this.properties = rest;
                    }
                }

                addValueChangedListener(fn) {
                    this.valueChangedListeners.push(fn);
                }
            }

            // Caches
            const sliderStates = new Map();
            const toggleStates = new Map();
            const comboBoxStates = new Map();

            // Public API
            window.Juce = window.Juce || {};

            window.Juce.getSliderState = function (name) {
                if (!sliderStates.has(name)) {
                    const state = new SliderState(name);
                    sliderStates.set(name, state);
                    console.log(`Created SliderState for: ${name}`, state);
                }
                return sliderStates.get(name);
            };

            window.Juce.getToggleState = function (name) {
                if (!toggleStates.has(name)) {
                    const state = new ToggleState(name);
                    toggleStates.set(name, state);
                    console.log(`Created ToggleState for: ${name}`, state);
                }
                return toggleStates.get(name);
            };

            window.Juce.getComboBoxState = function (name) {
                if (!comboBoxStates.has(name)) {
                    const state = new ComboBoxState(name);
                    comboBoxStates.set(name, state);
                    console.log(`Created ComboBoxState for: ${name}`, state);
                }
                return comboBoxStates.get(name);
            };

                console.log("JUCE parameter binding functions initialized");

            } catch (error) {
                console.error("CRITICAL ERROR in JUCE library initialization:", error);
                console.error("Error stack:", error.stack);
                window.juceLibraryError = error; // Store for debugging
            }
        })();

        // ============================================================================
        // CLOUDWASH UI IMPLEMENTATION
        // ============================================================================
        console.log("CloudWash Starting initialization...");

        // Debug UI helper (with null-safety)
        function updateDebugStatus(connected, message) {
            try {
                const overlay = document.getElementById('debugOverlay');
                const indicator = document.getElementById('debugIndicator');
                const messageEl = document.getElementById('debugMessage');

                // Null-safety checks
                if (!overlay || !indicator || !messageEl) {
                    console.error("Debug UI elements not found!");
                    return;
                }

                if (connected) {
                    overlay.classList.add('connected');
                    indicator.classList.add('connected');
                } else {
                    overlay.classList.remove('connected');
                    indicator.classList.remove('connected');
                }

                messageEl.textContent = message;

                // Hide debug overlay after 3 seconds if connected
                if (connected) {
                    setTimeout(() => {
                        if (overlay) overlay.classList.remove('active');
                    }, 3000);
                }
            } catch (e) {
                console.error("Error in updateDebugStatus:", e);
            }
        }

        document.addEventListener("DOMContentLoaded", () => {
            console.log("=== CloudWash Initialization ===");

            // Re-check JUCE availability after DOM load (WebView2 may need time to initialize)
            setTimeout(() => {
                let errorDetails = "";

                try {
                    const juceNowAvailable = typeof window.__JUCE__ !== 'undefined';
                    const hasBackend = juceNowAvailable && window.__JUCE__.backend;

                    if (hasBackend) {
                        console.log("✓ JUCE backend is CONNECTED");
                        updateDebugStatus(true, "✓ JUCE Connected - Parameters Active");
                    } else {
                        console.warn("⚠ JUCE backend NOT CONNECTED");

                        // Detailed diagnostics
                        if (!juceNowAvailable) {
                            errorDetails = "window.__JUCE__ does not exist - Native integration not enabled";
                            console.error("CRITICAL: window.__JUCE__ is undefined");
                            console.error("This means .withNativeIntegrationEnabled() is not working");
                        } else if (!window.__JUCE__.backend) {
                            errorDetails = "window.__JUCE__ exists but .backend is missing";
                            console.error("CRITICAL: window.__JUCE__.backend is undefined");
                            console.error("window.__JUCE__ contents:", window.__JUCE__);
                        }

                        updateDebugStatus(false, "⚠ JUCE NOT Connected - " + errorDetails);
                    }

                    // Try to initialize UI anyway (knobs will work visually but not control audio)
                    // Wrap each init function to find which one fails
                    try {
                        console.log("Initializing knobs...");
                        initializeKnobs();
                        console.log("✓ Knobs initialized");
                    } catch (e) {
                        console.error("✗ Knobs init failed:", e);
                        throw new Error("Knobs: " + e.message);
                    }

                    try {
                        console.log("Initializing mode tabs...");
                        initializeModeTabs();
                        console.log("✓ Mode tabs initialized");
                    } catch (e) {
                        console.error("✗ Mode tabs init failed:", e);
                        throw new Error("ModeTabs: " + e.message);
                    }

                    try {
                        console.log("Initializing freeze button...");
                        initializeFreezeButton();
                        console.log("✓ Freeze button initialized");
                    } catch (e) {
                        console.error("✗ Freeze button init failed:", e);
                        throw new Error("Freeze: " + e.message);
                    }

                    try {
                        console.log("Initializing dropdowns...");
                        initializeDropdowns();
                        console.log("✓ Dropdowns initialized");
                    } catch (e) {
                        console.error("✗ Dropdowns init failed:", e);
                        throw new Error("Dropdowns: " + e.message);
                    }

                    try {
                        console.log("Initializing meters...");
                        initializeMeters();
                        console.log("✓ Meters initialized");
                    } catch (e) {
                        console.error("✗ Meters init failed:", e);
                        throw new Error("Meters: " + e.message);
                    }

                    try {
                        console.log("Initializing grain visualization...");
                        initializeGrainVisualization();
                        console.log("✓ Grain visualization initialized");
                    } catch (e) {
                        console.error("✗ Grain viz init failed:", e);
                        throw new Error("GrainViz: " + e.message);
                    }

                    try {
                        console.log("Initializing presets...");
                        initializePresets();
                        console.log("✓ Presets initialized");
                    } catch (e) {
                        console.error("✗ Presets init failed:", e);
                        throw new Error("Presets: " + e.message);
                    }

                    console.log("✓ CloudWash UI fully initialized");

                } catch (error) {
                    console.error("Initialization Error:", error);
                    console.error("Error stack:", error.stack);
                    updateDebugStatus(false, "✗ Init Error: " + error.message);
                }
            }, 100); // 100ms delay to ensure WebView2 backend is ready
        });

        // ============================================================================
        // PRESET SYSTEM (20 Presets)
        // ============================================================================
        const presets = {
            init: { position: 0.5, size: 0.5, pitch: 0, density: 0.5, texture: 0.5, feedback: 0, in_gain: 0.8, blend: 0.5, spread: 0, reverb: 0, quality: 0, mode: 0, freeze: false, blend_mode: 0 },
            cloud: { position: 0.7, size: 0.8, pitch: 0.01, density: 0.65, texture: 0.4, feedback: 0.3, in_gain: 0.8, blend: 0.7, spread: 0.9, reverb: 0.6, quality: 1, mode: 0, freeze: false, blend_mode: 0 },
            storm: { position: 0.2, size: 0.3, pitch: -0.5, density: 0.9, texture: 0.8, feedback: 0.1, in_gain: 0.9, blend: 0.8, spread: 0.4, reverb: 0.2, quality: 1, mode: 0, freeze: false, blend_mode: 0 },
            spectral: { position: 0.5, size: 0.6, pitch: 0, density: 0.7, texture: 0.3, feedback: 0, in_gain: 0.7, blend: 1.0, spread: 0.6, reverb: 0.5, quality: 0, mode: 3, freeze: false, blend_mode: 0 },
            lofi: { position: 0.4, size: 0.5, pitch: -0.2, density: 0.4, texture: 0.9, feedback: 0.4, in_gain: 0.8, blend: 0.6, spread: 0.2, reverb: 0.3, quality: 3, mode: 0, freeze: false, blend_mode: 0 },
            frozen: { position: 0.5, size: 0.7, pitch: 0, density: 0.3, texture: 0.5, feedback: 0.5, in_gain: 0.8, blend: 0.9, spread: 0.5, reverb: 0.7, quality: 0, mode: 0, freeze: true, blend_mode: 0 },
            reverse: { position: 0.3, size: 0.6, pitch: 0, density: 0.6, texture: 0.4, feedback: 0.6, in_gain: 0.8, blend: 0.7, spread: 0.3, reverb: 0.4, quality: 1, mode: 0, freeze: false, blend_mode: 0 },
            shimmer: { position: 0.8, size: 0.9, pitch: 1.0, density: 0.5, texture: 0.2, feedback: 0.2, in_gain: 0.7, blend: 0.6, spread: 1.0, reverb: 0.9, quality: 0, mode: 0, freeze: false, blend_mode: 0 },
            glitch: { position: 0.1, size: 0.1, pitch: -0.4, density: 0.95, texture: 1.0, feedback: 0, in_gain: 1.0, blend: 0.9, spread: 0.1, reverb: 0.1, quality: 3, mode: 0, freeze: false, blend_mode: 0 },
            pitchshift: { position: 0.5, size: 0.4, pitch: 0.25, density: 0.5, texture: 0.5, feedback: 0, in_gain: 0.8, blend: 1.0, spread: 0, reverb: 0, quality: 0, mode: 1, freeze: false, blend_mode: 0 },
            loop: { position: 0.5, size: 0.5, pitch: 0, density: 0.6, texture: 0.5, feedback: 0.7, in_gain: 0.8, blend: 0.5, spread: 0.5, reverb: 0.3, quality: 1, mode: 2, freeze: false, blend_mode: 2 }, // Feedback blend mode
            ambient: { position: 0.6, size: 0.85, pitch: 0, density: 0.45, texture: 0.3, feedback: 0.4, in_gain: 0.7, blend: 0.8, spread: 0.8, reverb: 0.8, quality: 0, mode: 0, freeze: false, blend_mode: 0 },
            octup: { position: 0.5, size: 0.3, pitch: 1.0, density: 0.5, texture: 0.5, feedback: 0, in_gain: 0.8, blend: 0.8, spread: 0, reverb: 0.1, quality: 0, mode: 1, freeze: false, blend_mode: 0 },
            octdown: { position: 0.5, size: 0.3, pitch: -1.0, density: 0.5, texture: 0.5, feedback: 0, in_gain: 0.8, blend: 0.8, spread: 0, reverb: 0.1, quality: 0, mode: 1, freeze: false, blend_mode: 0 },
            specfreeze: { position: 0.5, size: 0.5, pitch: 0, density: 0.8, texture: 0.6, feedback: 0, in_gain: 0.7, blend: 1.0, spread: 0.7, reverb: 0.6, quality: 0, mode: 3, freeze: true, blend_mode: 0 },
            dense: { position: 0.4, size: 0.4, pitch: -0.04, density: 0.85, texture: 0.75, feedback: 0.3, in_gain: 0.85, blend: 0.75, spread: 0.6, reverb: 0.4, quality: 1, mode: 0, freeze: false, blend_mode: 0 },
            sparse: { position: 0.6, size: 0.8, pitch: 0, density: 0.2, texture: 0.6, feedback: 0.2, in_gain: 0.8, blend: 0.65, spread: 0.5, reverb: 0.5, quality: 0, mode: 0, freeze: false, blend_mode: 0 },
            cascade: { position: 0.3, size: 0.5, pitch: -0.3, density: 0.7, texture: 0.5, feedback: 0.8, in_gain: 0.8, blend: 0.7, spread: 0.4, reverb: 0.5, quality: 1, mode: 2, freeze: false, blend_mode: 2 }, // Feedback blend mode
            resonant: { position: 0.5, size: 0.6, pitch: 0, density: 0.6, texture: 0.4, feedback: 0.9, in_gain: 0.8, blend: 0.6, spread: 0.3, reverb: 0.2, quality: 0, mode: 2, freeze: false, blend_mode: 2 }, // Feedback blend mode
            chaos: { position: 0.15, size: 0.2, pitch: 0.1, density: 1.0, texture: 0.95, feedback: 0.5, in_gain: 0.9, blend: 0.85, spread: 0.7, reverb: 0.3, quality: 3, mode: 0, freeze: false, blend_mode: 0 }
        };

        function initializePresets() {
            const select = document.getElementById('presetSelect');
            const freezeButton = document.getElementById('freezeButton');

            select.addEventListener('change', (e) => {
                const preset = presets[e.target.value];
                if (!preset) return;

                console.log(`Applying preset: ${e.target.value}`);

                // Apply all parameters
                for (const [key, value] of Object.entries(preset)) {
                    // Handle mode switching
                    if (key === 'mode') {
                        const tab = document.querySelector(`.mode-tab[data-mode="${value}"]`);
                        if (tab) tab.click();
                        continue;
                    }

                    // Handle freeze toggle
                    if (key === 'freeze') {
                        const toggleState = window.Juce ? window.Juce.getToggleState('freeze') : null;
                        if (toggleState) {
                            toggleState.setValue(value);
                        } else if (freezeButton) {
                            freezeButton.classList.toggle('active', value);
                            document.getElementById('freezeLED').classList.toggle('active', value);
                        }
                        continue;
                    }

                    // Handle blend mode switching
                    if (key === 'blend_mode') {
                        const blendModeSelect = document.getElementById('blendModeSelect');
                        if (blendModeSelect) {
                            blendModeSelect.value = value;
                            blendModeSelect.dispatchEvent(new Event('change'));
                        }
                        continue;
                    }

                    const el = document.querySelector(`[data-param="${key}"]`);
                    if (!el) continue;

                    if (el.tagName === 'SELECT') {
                        el.value = value;
                        el.dispatchEvent(new Event('change'));
                    } else if (el.classList.contains('knob')) {
                        const sliderState = window.Juce ? window.Juce.getSliderState(key) : null;
                        if (sliderState) {
                            // Convert scaled back to normalized for the UI update
                            const min = parseFloat(el.dataset.min);
                            const max = parseFloat(el.dataset.max);
                            const norm = (value - min) / (max - min);
                            sliderState.setNormalisedValue(norm);
                        }
                    }
                }

                // Reset dropdown to placeholder after applying
                setTimeout(() => { select.selectedIndex = 0; }, 100);
            });
        }

        function initializeKnobs() {
            const knobs = document.querySelectorAll('.knob');
            console.log(`Initializing ${knobs.length} knobs...`);

            const ARC_START = 120;
            const ARC_RANGE = 300;
            const KNOB_RADIUS = 31;

            knobs.forEach((knob, index) => {
                const paramName = knob.dataset.param;
                const min = parseFloat(knob.dataset.min);
                const max = parseFloat(knob.dataset.max);
                const defaultValue = parseFloat(knob.dataset.default);

                let isDragging = false;
                let startY = 0;
                let startNormalized = 0;

                const track = knob.querySelector('.knob-track');
                const arc = knob.querySelector('.knob-arc');
                const indicator = knob.querySelector('.knob-indicator');
                const valueDisplay = knob.parentElement.querySelector('.knob-value');

                // Create JUCE slider state for this parameter
                const sliderState = window.Juce ? window.Juce.getSliderState(paramName) : null;

                function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
                    const angleInRadians = angleInDegrees * Math.PI / 180.0;
                    return {
                        x: centerX + (radius * Math.cos(angleInRadians)),
                        y: centerY + (radius * Math.sin(angleInRadians))
                    };
                }

                function describeArc(x, y, radius, startAngle, endAngle) {
                    const start = polarToCartesian(x, y, radius, endAngle);
                    const end = polarToCartesian(x, y, radius, startAngle);
                    const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
                    return `M ${start.x} ${start.y} A ${radius} ${radius} 0 ${largeArcFlag} 0 ${end.x} ${end.y}`;
                }

                function updateVisualFromValue(value) {
                    const normalized = (value - min) / (max - min);

                    // Draw track
                    const trackPath = describeArc(35, 35, KNOB_RADIUS, ARC_START, ARC_START + ARC_RANGE);
                    track.setAttribute('d', trackPath);

                    // Draw arc
                    const endAngle = ARC_START + (ARC_RANGE * normalized);
                    const arcPath = describeArc(35, 35, KNOB_RADIUS, ARC_START, endAngle);
                    arc.setAttribute('d', arcPath);

                    // Position indicator
                    const angle = (ARC_START + (ARC_RANGE * normalized)) * Math.PI / 180;
                    const indicatorX = 35 + KNOB_RADIUS * Math.cos(angle) - 3.5;
                    const indicatorY = 35 + KNOB_RADIUS * Math.sin(angle) - 3.5;
                    indicator.style.left = `${indicatorX}px`;
                    indicator.style.top = `${indicatorY}px`;

                    // Update value display
                    if (paramName === 'pitch') {
                        valueDisplay.textContent = value >= 0 ? `+${value.toFixed(2)}` : value.toFixed(2);
                    } else {
                        valueDisplay.textContent = `${Math.round(normalized * 100)}%`;
                    }
                }

                // Listen for parameter changes from JUCE (automation, preset load, etc.)
                if (sliderState) {
                    sliderState.addValueChangedListener(() => {
                        const value = sliderState.getScaledValue();
                        updateVisualFromValue(value);
                    });
                }

                // Mouse drag handling
                knob.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    isDragging = true;
                    startY = e.clientY;

                    if (sliderState) {
                        startNormalized = sliderState.getNormalisedValue();
                        sliderState.sliderDragStarted();
                    } else {
                        startNormalized = (defaultValue - min) / (max - min);
                    }

                    knob.classList.add('active');
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaY = startY - e.clientY;
                        const sensitivity = 0.005;
                        const range = max - min;
                        const deltaNormalized = deltaY * sensitivity;
                        let newNormalized = startNormalized + deltaNormalized;
                        newNormalized = Math.max(0, Math.min(1, newNormalized));

                        if (sliderState) {
                            // Send to JUCE backend
                            sliderState.setNormalisedValue(newNormalized);
                        } else {
                            // Standalone mode - just update visuals
                            const newValue = min + newNormalized * range;
                            updateVisualFromValue(newValue);
                        }
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        knob.classList.remove('active');

                        if (sliderState) {
                            sliderState.sliderDragEnded();
                        }
                    }
                });

                // Double-click to reset
                knob.addEventListener('dblclick', () => {
                    const normalizedDefault = (defaultValue - min) / (max - min);
                    if (sliderState) {
                        sliderState.setNormalisedValue(normalizedDefault);
                    } else {
                        updateVisualFromValue(defaultValue);
                    }
                });

                // Initialize visual from JUCE state or default
                if (sliderState) {
                    const initialValue = sliderState.getScaledValue();
                    updateVisualFromValue(initialValue);
                } else {
                    updateVisualFromValue(defaultValue);
                }

                console.log(`  ✓ ${paramName}`);
            });
        }

        function initializeModeTabs() {
            try {
                const modeTabs = document.querySelectorAll('.mode-tab');
                console.log(`Initializing ${modeTabs.length} mode tabs...`);

                const sliderState = window.Juce ? window.Juce.getSliderState('mode') : null;

                // Handle user clicks
                modeTabs.forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        console.log(`Tab clicked: ${tab.dataset.mode}`);
                        const modeIndex = parseInt(tab.dataset.mode);

                        if (sliderState) {
                            sliderState.setNormalisedValue(modeIndex / 3.0);
                        } else {
                            // Standalone mode visual backup
                            modeTabs.forEach(t => t.classList.remove('active'));
                            tab.classList.add('active');
                        }
                    });
                });

                // Listen for mode changes from JUCE
                if (sliderState) {
                    sliderState.addValueChangedListener(() => {
                        const normalizedValue = sliderState.getNormalisedValue();
                        const modeIndex = Math.round(normalizedValue * 3.0);
                        console.log(`Mode updated from JUCE: ${modeIndex}`);
                        modeTabs.forEach((tab, idx) => {
                            tab.classList.toggle('active', idx === modeIndex);
                        });
                    });

                    // Initial state
                    const initialValue = sliderState.getNormalisedValue();
                    const initialMode = Math.round(initialValue * 3.0);
                    modeTabs.forEach((tab, idx) => {
                        tab.classList.toggle('active', idx === initialMode);
                    });
                }

                console.log("✓ Mode tabs fully initialized");
            } catch (err) {
                console.error("Failed to initialize mode tabs:", err);
            }
        }

        function initializeFreezeButton() {
            const freezeButton = document.getElementById('freezeButton');
            const freezeLED = document.getElementById('freezeLED');
            const toggleState = window.Juce ? window.Juce.getToggleState('freeze') : null;

            // Listen for freeze changes from JUCE
            if (toggleState) {
                toggleState.addValueChangedListener(() => {
                    const isActive = toggleState.getValue();
                    freezeButton.classList.toggle('active', isActive);
                    freezeLED.classList.toggle('active', isActive);
                });
            }

            // Handle user clicks
            freezeButton.addEventListener('click', () => {
                if (toggleState) {
                    const newValue = !toggleState.getValue();
                    toggleState.setValue(newValue);
                } else {
                    // Standalone mode
                    const isActive = freezeButton.classList.contains('active');
                    freezeButton.classList.toggle('active', !isActive);
                    freezeLED.classList.toggle('active', !isActive);
                }
            });

            // Initialize from JUCE state
            if (toggleState) {
                const initialValue = toggleState.getValue();
                freezeButton.classList.toggle('active', initialValue);
                freezeLED.classList.toggle('active', initialValue);
            }

            console.log("✓ Freeze button");
        }

        function initializeDropdowns() {
            const qualitySelect = document.getElementById('qualitySelect');
            const blendModeSelect = document.getElementById('blendModeSelect');

            if (!qualitySelect) {
                console.error("Quality dropdown not found in HTML!");
                return;
            }

            // Quality dropdown
            const qualityState = window.Juce ? window.Juce.getSliderState('quality') : null;
            if (qualityState) {
                qualityState.addValueChangedListener(() => {
                    const normalized = qualityState.getNormalisedValue();
                    if (qualitySelect) qualitySelect.selectedIndex = Math.round(normalized * 4.0); // 0-4 for 5 options
                });

                qualitySelect.addEventListener('change', () => {
                    qualityState.setNormalisedValue(qualitySelect.selectedIndex / 4.0); // 0-4 for 5 options
                });

                // Initialize
                qualitySelect.selectedIndex = Math.round(qualityState.getNormalisedValue() * 4.0);
            } else {
                qualitySelect.addEventListener('change', () => {
                    console.log('Quality changed (standalone):', qualitySelect.value);
                });
            }

            // CRITICAL FIX: Blend Mode dropdown for VCV Rack compatibility
            // VCV Rack: blendMode determines which parameter the BLEND_INPUT modulates
            const blendModeState = window.Juce ? window.Juce.getSliderState('blend_mode') : null;
            if (blendModeState && blendModeSelect) {
                blendModeState.addValueChangedListener(() => {
                    const normalized = blendModeState.getNormalisedValue();
                    if (blendModeSelect) blendModeSelect.selectedIndex = Math.round(normalized * 3.0); // 0-3 for 4 options
                });

                blendModeSelect.addEventListener('change', () => {
                    blendModeState.setNormalisedValue(blendModeSelect.selectedIndex / 3.0); // 0-3 for 4 options
                });

                // Initialize
                blendModeSelect.selectedIndex = Math.round(blendModeState.getNormalisedValue() * 3.0);
            } else if (blendModeSelect) {
                blendModeSelect.addEventListener('change', () => {
                    console.log('Blend mode changed (standalone):', blendModeSelect.value);
                });
            }

            // Sample Mode dropdown - removed because it doesn't exist in the UI
            // The sample_mode parameter exists but we don't have a UI control for it

            console.log("✓ Dropdowns");
        }

        function initializeMeters() {
            const inputMeter = document.getElementById('inputMeter');
            const outputMeter = document.getElementById('outputMeter');

            function createMeterSegments(meter) {
                for (let i = 0; i < 24; i++) {
                    const segment = document.createElement('div');
                    segment.className = 'meter-segment';
                    meter.appendChild(segment);
                }
            }

            createMeterSegments(inputMeter);
            createMeterSegments(outputMeter);

            function updateMeter(meter, level) {
                // Validate input level is within [0, 1] range to prevent display issues
                const clampedLevel = Math.max(0, Math.min(1, level));
                const segments = meter.querySelectorAll('.meter-segment');
                const activeSegments = Math.floor(clampedLevel * 24);

                segments.forEach((segment, index) => {
                    segment.classList.remove('active', 'green', 'yellow', 'red');
                    if (index < activeSegments) {
                        segment.classList.add('active');
                        if (index < 19) segment.classList.add('green');
                        else if (index < 23) segment.classList.add('yellow');
                        else segment.classList.add('red');
                    }
                });
            }

            // ============================================================
            // METER UPDATE: Connected to Real Audio
            // ============================================================
            // Global function called from C++ (via evaluateJavascript)
            // Called at 30 Hz from PluginEditor::timerCallback()
            window.updateMeters = function (inputLevel, outputLevel) {
                updateMeter(inputMeter, inputLevel);
                updateMeter(outputMeter, outputLevel);
            };

            console.log("✓ Meters (connected to real audio levels)");
        }

        function initializeGrainVisualization() {
            const canvas = document.getElementById('grainCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 680;
            canvas.height = 60;

            const MAX_PARTICLES = 64; // Match MAX_GRAINS from C++
            const particles = [];

            // Initialize particle pool
            for (let i = 0; i < MAX_PARTICLES; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.3,
                    size: 2 + Math.random() * 3,
                    opacity: 0.3 + Math.random() * 0.3,
                    active: false
                });
            }

            let currentActiveCount = 0;
            let currentDensity = 0.5;
            let currentTexture = 0.5;

            // Called from C++ at 30 Hz with real grain data
            window.updateGrainVisualization = function (activeGrains, density, texture) {
                currentActiveCount = activeGrains;
                currentDensity = density;
                currentTexture = texture;
            };

            function animateGrains() {
                // Fade trail effect
                ctx.fillStyle = 'rgba(26, 26, 46, 0.15)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Calculate how many particles should be visible based on active grain count
                const targetVisibleCount = Math.min(currentActiveCount, MAX_PARTICLES);

                // Update particle activity states
                for (let i = 0; i < particles.length; i++) {
                    particles[i].active = i < targetVisibleCount;
                }

                // Animate active particles
                particles.forEach(p => {
                    if (!p.active) return;

                    // Speed influenced by density (more density = faster movement)
                    const speedMultiplier = 0.5 + currentDensity * 1.5;
                    p.x += p.vx * speedMultiplier;
                    p.y += p.vy * speedMultiplier;

                    // Bounce off edges
                    if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
                    if (p.y < 0 || p.y > canvas.height) p.vy *= -1;

                    // Size influenced by texture (0 = small/smooth, 1 = large/rough)
                    const sizeMultiplier = 1.0 + currentTexture * 2.0;
                    const displaySize = p.size * sizeMultiplier;

                    // Opacity influenced by density
                    const displayOpacity = 0.2 + currentDensity * 0.6;

                    // Color variation based on texture
                    // Smooth (low texture) = pure cyan, Rough (high texture) = more teal
                    const hue = 185 - currentTexture * 15; // 185 = cyan, 170 = teal
                    ctx.fillStyle = `hsla(${hue}, 70%, 65%, ${displayOpacity})`;

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, displaySize, 0, Math.PI * 2);
                    ctx.fill();

                    // Add glow effect for active grains
                    if (currentDensity > 0.5) {
                        ctx.shadowBlur = 8 * currentDensity;
                        ctx.shadowColor = `hsla(${hue}, 70%, 65%, ${displayOpacity * 0.5})`;
                    } else {
                        ctx.shadowBlur = 0;
                    }
                });

                requestAnimationFrame(animateGrains);
            }

            animateGrains();
            console.log("✓ Grain visualization (connected to real grain data)");
        }

        // ============================================================================
        // GLOBAL DEBUG FUNCTION (call from console: testBackend())
        // ============================================================================
        window.testBackend = function() {
            console.log("=== JUCE Backend Test ===");
            console.log("window.__JUCE__ exists:", typeof window.__JUCE__ !== 'undefined');

            if (window.__JUCE__) {
                console.log("window.__JUCE__.backend exists:", typeof window.__JUCE__.backend !== 'undefined');
                console.log("window.__JUCE__ contents:", window.__JUCE__);

                if (window.__JUCE__.backend) {
                    console.log("✓ Backend is connected!");

                    // Try to create a test slider
                    try {
                        const testSlider = window.Juce.getSliderState('position');
                        console.log("Test slider created:", testSlider);
                        console.log("Current value:", testSlider.getScaledValue());
                    } catch (e) {
                        console.error("Error creating test slider:", e);
                    }
                } else {
                    console.error("✗ window.__JUCE__ exists but .backend is missing");
                }
            } else {
                console.error("✗ window.__JUCE__ does not exist");
                console.log("This means WebView native integration is not working");
            }

            // Also test if relays are registered
            console.log("\nParameter Relays:");
            console.log("  positionRelay ID:", window.positionRelay?.identifier || "NOT FOUND");

            return "Test complete - check logs above";
        };

        // Show debug message on load
        console.log("💡 Type testBackend() in console to check JUCE connection");
    </script>
</body>

</html>